C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE _制系统
OBJECT MODULE PLACED IN 控制系统.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 控制系统.c ROM(COMPACT) OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**************************************************************************************
   2           程序名称：
   3                     时间 温度控制系统（128*64LCD+ds1302+ds18b20）
   4           主要功能：
   5                     温度计 时钟 闹铃 密码锁 篮球器 计算器 温度控制 键盘锁 系统设置等。
   6           主要说明：
   7                     程序全部定义在一个C文件中。
   8           作者：    
   9                     LiJH
  10           时间：   
  11                     2008.6.20
  12           版本：   
  13                     LiJH-V1.0
  14           **************************************************************************************/
  15          
  16          
  17          #include    <at89s53.h>
  18          #include    <intrins.h>         
  19          #define     uchar        unsigned char
  20          #define     uint         unsigned int
  21          #define     time_count   0x3cb0
  22          #define     close        1
  23          #define     open         0
  24          
  25          /*============ 状态控制及温感器总线定义 ==============*/ 
  26           
  27          #define     b20_io       P0_0           // DS18B20总线    
  28          #define     pw_oc        P3_7           // 密码锁开启控制(黄灯)
  29          #define     buzzer       P0_5           // 蜂鸣器
  30          #define     lcd_bl       P0_6           // 背光控制口
  31          #define     als_th       P0_4           // 上限温度警报(红灯)
  32          #define     als_tl       P3_6           // 下限温度警报(绿灯)
  33          #define     keyboard     P1                     // 键盘数据口
  34          
  35          
  36          /*================= ST7920LCD 定义 ===================*/
  37          
  38          #define     comm         0                      // lcd指令
  39          #define     dat          1                      // lcd数据
  40          #define     lcd_rst      P0_7           // lcd复位
  41          #define     lcd_e        P3_0           // lcd使能
  42          #define     lcd_rw       P3_1           // lcd读写
  43          #define     lcd_rs       P3_2           // lcd数据命令
  44          #define     busy         P2_7       // 忙碌位
  45          #define     lcd_data     P2                     // lcd(8bit)数据传输 
  46          
  47            
  48          /*=============== DS1302 寄存器地址定义 ===============*/
  49          
  50          #define         d02_rst      P0_1               // DS1302使能
  51          #define         d02_data     P0_2               // DS1302数据线
  52          #define         d02_sclk     P0_3               // DS1302脉冲
  53          #define     d02_wrc      0x8e           // 1302读写RAM控制(1允许 0禁止)
  54          #define     d02_year     0x8c           // 年
  55          #define     d02_weeks    0x8a           // 星期
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 2   

  56          #define     d02_month    0x88           // 月
  57          #define     d02_day              0x86           // 日
  58          #define     d02_hour     0x84           // 时
  59          #define     d02_minute   0x82           // 分
  60          #define     d02_second   0x80           // 秒
  61          #define     d02_signs    0xc0           // 系统状态(记录设置标记)
  62          #define     d02_passw    0xc2           // 密码寄存器首位（有3位下位地址加2，初始值为：741456）
  63          #define     d02_alm              0xc8           // 闹铃时间小时位（下位为分钟位加2）
  64          #define     d02_temp     0xcc           // 温度上限警报（有两位下位位下限加2）
  65          #define     d02_initsi   0xd4           // 1302初始化标记（为0xb4时，说明已经初始化）
  66          #define     ret_ds1302()    d02_rst=0;d02_sclk=0;d02_rst=1      // 1302读写复位
  67          #define     end_ds1302()    d02_sclk=1;d02_rst=0                        // 1302读写结束
  68          
  69          
  70          
  71          /*================================= 全局变量定义 ==================================*/
  72          
  73          
  74          typedef struct                  // 定义时间类型 
  75          {
  76            uchar hour;
  77            uchar minute;
  78            uchar second;
  79          }time;
  80          
  81          typedef struct                  // 定义日期类型 
  82          {
  83            uchar year;
  84            uchar month;
  85            uchar day;
  86            uchar week;
  87          }date;
  88          
  89          typedef union               // 定义温度类型
  90          {
  91            int temp_data;
  92            uchar t_data[2];
  93          }trdata;
  94          
  95          trdata  bdata  temp;             // 温度警报值暂存      
  96          date    idata  today={'8',1,1,1};        // 日期暂存
  97          time    idata  now={0x12,0,0} , save_time={0x12,0,0}; 
  98                        // 时间暂存(now是读出时间暂存 save_time上一时间暂存)
  99          uchar   idata  time_tick=20,time_tick1=20,alarm_time[2],als_temp[2], 
 100                        // T0中断数,     T1中断数,     闹铃时间,   警报温度
 101                         bl_delay=15,temp_delay=5,opera[2][12],resu[12], 
 102                                    // 背光时间,  温度更新时间, 计算器数据寄存, 结果寄存
 103                                     i,j,save1,temp_min=0; 
 104                                     // 计算器i/j下标，中间暂存,温度更新（分）
 105          
 106          
 107          
 108          uchar  bdata   signs=0;          // 系统标记寄存器
 109            sbit bl1=signs^7;              // bl1,bl0背光选择位(00 延时,01 常开,10 关闭) 
 110            sbit bl0=signs^6;                     
 111            sbit di1=signs^5;                      // di1,di0显示模式(00模式1,01模式2,10模式3)
 112            sbit di0=signs^4;                     
 113            sbit meu=signs^3;                      // 菜单显示方式(0 图片,1 文字)
 114            sbit keb=signs^2;                      // 键盘锁(0 无锁,1加锁)
 115            sbit alm=signs^1;                      // 闹钟启动位(0 关闭,1开启)
 116            sbit als=signs^0;                      // 报警启动位(0 启动,1关闭)
 117          
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 3   

 118          
 119          
 120          uint   bdata   run_signs=0;     // 运行标记寄存器
 121            sbit ds18b20=run_signs^0;             // 温感器存在标记(0不存在，1存在)
 122            sbit temp_pn=run_signs^1;             // 温度正负号标记(0正，1负)
 123            sbit temprun=run_signs^2;             // 温感器运行标记(0否，1启动)
 124            sbit nba_tim=run_signs^3;     // 篮球计时器标记(0关闭，1启动)
 125            sbit adju_si=run_signs^4;             // 数字更改连续标记(1连续)
 126            sbit cal_del=run_signs^5;     // 计算器显示点标记（0没有显示）
 127            sbit cal_run=run_signs^6;         // 计算完毕标记（1有效）
 128            sbit oth_run=run_signs^7;     // 其他标记
 129            sbit alm_run=run_signs^8;     // 闹钟时间到达标记（1有效）
 130            sbit dis_sig=run_signs^9;     // 显示时间标记（1有效）
 131            sbit lock_op=run_signs^10;    // 关锁时间到标记（1有效）
 132            sbit b20time=run_signs^11;    // 温感器重新读温度标记(1有效)
 133            sbit t0_isr =run_signs^12;    // TO中断标记（1有效(1s)
 134            sbit thl_als=run_signs^13;    // 温度警报标记
 135            sbit init_d2=run_signs^14;    // 模式2初始显示
 136            sbit buzstop=run_signs^15;    // 蜂鸣器停止标记
 137          
 138          
 139          
 140          
 141          /*================================= 字体显示代码 ==================================*/ 
 142          
 143          uchar code weeks[7][2]={"一","二","三","四","五","六","日"}; // 星期                            //图片中文
 144          uchar code menu_cn[6][8]={"调    整","工    具","设    置","保    密","版    本","退    出"};
 145          uchar code menu_cn_2[6][6]={"调  整","工  具","设  置","保  密","版  本","退  出"};// 菜单文字
 146          uchar code selected[2][16]={{"进入【      】\x04 "},{"设置【    】\x10 \x04 "}}; // 选框
 147          uchar code secrets_menu[4][6]={"开  锁","更  改","初始化","退  出"};           // 保密菜单中文
 148          uchar code tool_menu[5][6]={"计算器","温度计","闹  铃","篮球器","退  出"};         // 工具菜单中文
 149          uchar code char_num[10]={"0123456789"};  // 数字显示代码                                                         // 每月天数
 150          uchar code dayofmonth[12]={0x31,0x28,0x31,0x30,0x31,0x30,0x31,0x31,0x30,0x31,0x30,0x31}; 
 151          uchar code key_code[]={0xD7,0x7E,0x7D,0x7B,0xBE,0xBD,0xBB,0xDE,0xDD,0xDB,0xB7,0x77,0xEE,0xED,0xEB,0xE7};
 152          uchar code ksp[4]={0x7F,0xBF,0xDF,0xEF};         // 按键扫描代码
 153          uchar code tool_cal[4][2]={"+ ","- ","* ","/ "}; // 运算符号
 154          uchar code alm_sign[2][2]={"关","开"};                   // 闹铃开关
 155          uchar code set_bl_dm[2][3][4]={{"30秒","常开","关闭"},{"模01","模02","模03"}};
 156          uchar code set_mka[3][2][4]={{"图片","文字"},{"解锁","加锁"},{"开启","关闭"}};
 157          uchar code nba_oppo[8][2]={"红","白","蓝","绿","紫","灰","黄","黑"};
 158          uchar code set_menu[6][4]={"背光","显示","菜单","键盘","警报","退出"};
 159          
 160          
 161          uchar code version[10][14]={   // 版本信息
 162                                      {"清远职业技术学"},
 163                                                                  {"  信息科技学院"},
 164                                                          {"08届毕业设计  "},
 165                                                          {"  ―05电子02班"},
 166                                                  {"作者：李锦华  "},
 167                                                          {"指导：李祖明  "},
 168                                                          {"版本:LIJH-V1.0"},
 169                                                          {"    2008/06/19"},
 170                                                          {"谢谢你的使用！"},
 171                                                          {"         (ok)\x10"}};
 172          
 173          
 174          uchar code timer_tips[12][16]={ // 篮球器使用说明
 175                                      {"使用方法：      "},
 176                                                                  {"  (+)(-)与(*)(/)"},
 177                                                                  {"分别是两方的分数"},
 178                                                                  {"加与减,(7)键回退"},
 179                                                                  {"一秒,(8)键24秒复"},
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 4   

 180                                                                  {"位,(9)键暂停与开"},
 181                                                                  {"始；暂停状态下："},
 182                                                                  {"按两次(OK)键可返"},
 183                                                                  {"回时钟模式-2界面"},
 184                                                                  {"，(OK)键返回程序"},
 185                                                                  {"界面,(./S)键两次"},
 186                                                                  {"退出程序.      \x1f"}};
 187          
 188          
 189          
 190          /*================================= 操作导航代码 ==================================*/ 
 191          
 192           
 193          typedef struct                  // 定义主菜单操作索引 
 194          {
 195            uchar shaft_num;
 196            uchar left_num;
 197            uchar right_num;
 198          }menu_index;
 199          
 200          typedef struct                  // 定义导航更改索引 
 201          {
 202            uchar lnum;
 203            uchar rnum;
 204          }index;
 205          
 206          menu_index code index_m[6]={{3,5,1},{4,0,2},{5,1,3},{0,2,4},{1,3,5},{2,4,0}}; // 菜单导航
 207          index code index_t[6]={{4,1},{0,2},{1,3},{2,4},{3,0}};       // 工具导航
 208          index code index_p[5]={{3,1},{0,2},{1,3},{2,0}};             // 保密导航
 209          index code index_s[6]={{5,1},{0,2},{1,3},{2,4},{3,5},{4,0}}; // 设置导航
 210          index code index_a[7]={{0x81,0x91},{0x83,0x91},{0x85,0x91},{0x89,0x81},
 211                                          {0x8b,0x81},{0x8d,0x81},{0x8f,0x91}};       // 调整下的坐标
 212          index code index_temp_set[3]={{0x8b,0x81},{0x8b,0x91},{0x8f,0x91}}; // 温度设定下的坐标
 213          index code index_alm[3]={{0x8c,0x81},{0x8e,0x81},{0x8f,0x91}};      // 闹铃更改坐标     
 214          index code index_cal[3]={{0x86,0x90},{0x8e,0x80},{0x8e,0x90}};      // 计算器操作坐标
 215          uchar code index_nba[4]={0x93,0x97,0x8b,0x8f};                                      // 篮球器设置导航
 216          
 217          
 218          
 219          
 220          
 221          /*========================== 菜单图片（宽度x高度=32*24）=============================*/
 222          
 223          uchar code menu_pic[6][96]={ 
 224                  {// 调整 
 225                   0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x40,0x00,0x00,0x02,0x40,0x00,0x00,0x02,
 226                   0x40,0x00,0x00,0x82,0x47,0xFF,0xE1,0xC2,0x47,0xFF,0xF3,0xE2,0x47,0x38,0x68,0x02,
 227                   0x46,0xDF,0x68,0x82,0x46,0xDF,0x69,0xC2,0x46,0xDE,0xE8,0x82,0x46,0xDD,0xE8,0x02,
 228                   0x46,0xDD,0xE8,0x02,0x47,0x3D,0xE8,0x02,0x47,0xFF,0xE8,0x02,0x47,0xFF,0xE9,0xC2,
 229                   0x42,0x00,0x18,0x02,0x41,0xFF,0xF3,0xE2,0x40,0x00,0x01,0xC2,0x40,0x00,0x00,0x82,
 230                   0x40,0x00,0x00,0x02,0x40,0x00,0x00,0x02,0x7F,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00},
 231                  
 232                  {// 工具                                        
 233                   0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x40,0x00,0x00,0x02,0x40,0x00,0x03,0x82,
 234                   0x41,0xF0,0x07,0xC2,0x43,0xFF,0xCF,0xE2,0x47,0x3F,0xFE,0x02,0x47,0x3F,0xFE,0x02,
 235                   0x43,0xFF,0xCF,0xE2,0x41,0xF0,0x0F,0xC2,0x40,0x00,0x03,0x82,0x40,0x00,0x00,0x02,
 236                   0x40,0x00,0x03,0xC2,0x40,0x00,0x03,0xC2,0x41,0x80,0x01,0x82,0x43,0xFF,0xF3,0xC2,
 237                   0x47,0xFF,0xFF,0xE2,0x47,0xFF,0xFF,0xE2,0x43,0xFF,0xF3,0xC2,0x41,0x80,0x01,0x82,
 238                   0x40,0x00,0x01,0x82,0x40,0x00,0x00,0x02,0x7F,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00},
 239                  
 240                  {// 设置
 241                   0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x40,0x00,0x00,0x02,0x43,0x18,0x00,0x02,
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 5   

 242                   0x44,0xA4,0x0E,0x02,0x44,0xA4,0x1F,0x02,0x43,0x24,0x3F,0x02,0x40,0x00,0x7F,0x02,
 243                   0x40,0xF0,0xFC,0x02,0x43,0xF9,0xF0,0x02,0x43,0x03,0xE0,0x02,0x46,0x77,0x80,0x02,
 244                   0x46,0x7F,0x00,0x02,0x46,0x7E,0x00,0x02,0x46,0x7C,0x00,0x02,0x47,0x3D,0x00,0x02,
 245                   0x43,0x1D,0x81,0x22,0x43,0x81,0xB2,0x42,0x41,0xC3,0x4F,0xE2,0x40,0xFE,0x4A,0x42,
 246                   0x40,0x3C,0x32,0x42,0x40,0x00,0x00,0x02,0x7F,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00},
 247                  
 248                  {// 保密
 249                   0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x40,0x00,0x00,0x02,0x40,0xFC,0x03,0x02,
 250                   0x41,0xFE,0x1F,0x02,0x43,0x87,0x03,0x82,0x43,0x03,0x03,0x02,0x43,0x03,0x03,0x02,
 251                   0x43,0x03,0x0F,0x02,0x43,0x03,0x03,0x02,0x43,0x03,0x03,0x02,0x47,0xFF,0x83,0x02,
 252                   0x47,0xFF,0x83,0x02,0x47,0xCF,0x83,0x02,0x47,0x87,0x83,0x02,0x47,0xCF,0x83,0x02,
 253                   0x47,0xCF,0x87,0x82,0x47,0xCF,0x8F,0xC2,0x47,0xCF,0x9C,0xE2,0x47,0xFF,0x8F,0xC2,
 254                   0x43,0xFF,0x07,0x82,0x40,0x00,0x00,0x02,0x7F,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00},
 255                  
 256                  {// 版本
 257                   0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x40,0x00,0x00,0x02,0x40,0x00,0x00,0x02,
 258                   0x40,0x0F,0x00,0x62,0x40,0x1D,0x80,0xF2,0x40,0x38,0x41,0xF2,0x40,0x70,0x23,0xE2,
 259                   0x40,0xE2,0x17,0xC2,0x41,0xE4,0x4F,0x82,0x41,0xF0,0x9F,0x02,0x41,0x59,0x16,0x02,
 260                   0x42,0x4C,0x1D,0x02,0x42,0x46,0x20,0x82,0x42,0x47,0x00,0x42,0x44,0x43,0x80,0xC2,
 261                   0x44,0x44,0xC1,0xC2,0x44,0xC8,0x63,0x82,0x45,0x50,0x37,0x02,0x46,0x60,0x1E,0x02,
 262                   0x40,0x40,0x0C,0x02,0x40,0x00,0x00,0x02,0x7F,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00},
 263                  
 264                  {// 退出
 265                   0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFE,0x40,0x00,0x00,0x02,0x40,0x40,0xFF,0xE2,
 266                   0x40,0x60,0x80,0x62,0x43,0xF0,0x80,0xA2,0x43,0xF0,0x81,0x22,0x40,0x60,0x82,0x22,
 267                   0x40,0x40,0x84,0x22,0x40,0x00,0x88,0x22,0x40,0x00,0x88,0x22,0x47,0xFF,0xF8,0x22,
 268                   0x47,0xFF,0xF8,0x22,0x46,0x2A,0x2A,0x22,0x46,0xE3,0x78,0x22,0x46,0x77,0x78,0x22,
 269                   0x46,0xE3,0x78,0x62,0x46,0x2A,0x38,0x82,0x47,0xFF,0xF9,0x02,0x47,0xFF,0xFA,0x02,
 270                   0x40,0x00,0x0C,0x02,0x40,0x00,0x00,0x02,0x7F,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,}};
 271          
 272          
 273          
 274          
 275          /*================ 显示模式2数字及温度符号图片（宽度x高度=16*32）=====================*/
 276          
 277          uchar code mode_2num[11][64]={
 278                  {// 图片数字0
 279                   0x00,0x00,0x3F,0xFC,0x5F,0xFA,0x6F,0xF6,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,
 280                   0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x60,0x06,0x40,0x02,0x00,0x00,
 281                   0x40,0x02,0x60,0x06,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,
 282                   0x70,0x0E,0x70,0x0E,0x70,0x0E,0x6F,0xF6,0x5F,0xFA,0x3F,0xFC,0x00,0x00,0x00,0x00},
 283                  
 284                  {// 图片数字1
 285                   0x00,0x00,0x00,0x20,0x00,0x60,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,
 286               0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0x60,0x00,0x20,0x00,0x00,0x00,0x20,
 287                   0x00,0x60,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0xE0,
 288                   0x00,0xE0,0x00,0xE0,0x00,0xE0,0x00,0x60,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00},
 289              
 290                  {// 图片数字2
 291                   0x00,0x00,0x3F,0xFC,0x1F,0xFA,0x0F,0xF6,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 292                   0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x06,0x1F,0xFA,0x3F,0xFC,
 293                   0x5F,0xF8,0x60,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,
 294                   0x70,0x00,0x70,0x00,0x70,0x00,0x6F,0xF8,0x5F,0xFC,0x3F,0xFE,0x00,0x00,0x00,0x00},
 295                  
 296                  {// 图片数字3
 297                   0x00,0x00,0x7F,0xFC,0x3F,0xFA,0x1F,0xF6,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 298               0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x06,0x1F,0xFA,0x3F,0xFC,
 299               0x1F,0xFA,0x00,0x06,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 300               0x00,0x0E,0x00,0x0E,0x00,0x0E,0x1F,0xF6,0x3F,0xFA,0x7F,0xFC,0x00,0x00,0x00,0x00},
 301                  
 302                  {// 图片数字4
 303                   0x00,0x00,0x40,0x02,0x60,0x06,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 6   

 304                   0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x60,0x06,0x5F,0xFA,0x3F,0xFC,
 305                   0x1F,0xFA,0x00,0x06,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 306                   0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x06,0x00,0x02,0x00,0x00,0x00,0x00},
 307                  
 308                  {// 图片数字5
 309                   0x00,0x00,0x3F,0xFC,0x5F,0xF8,0x6F,0xF0,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,
 310                   0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x60,0x00,0x5F,0xF8,0x3F,0xFC,
 311                   0x1F,0xFA,0x00,0x06,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 312                   0x00,0x0E,0x00,0x0E,0x00,0x0E,0x0F,0xF6,0x1F,0xFA,0x3F,0xFC,0x00,0x00,0x00,0x00},
 313                  
 314                  {// 图片数字6
 315                   0x00,0x00,0x3F,0xFC,0x5F,0xF8,0x6F,0xF0,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,
 316                   0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x60,0x00,0x5F,0xF8,0x3F,0xFC,
 317                   0x5F,0xFA,0x60,0x06,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,
 318                   0x70,0x0E,0x70,0x0E,0x70,0x0E,0x6F,0xF6,0x5F,0xFA,0x3F,0xFC,0x00,0x00,0x00,0x00},
 319                  
 320                  {// 图片数字7
 321                   0x00,0x00,0x7F,0xFC,0x3F,0xFA,0x1F,0xF6,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 322                   0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x06,0x00,0x02,0x00,0x00,
 323                   0x00,0x02,0x00,0x06,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 324                   0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x06,0x00,0x02,0x00,0x00,0x00,0x00},
 325                  
 326                  {// 图片数字8
 327                   0x00,0x00,0x3F,0xFC,0x5F,0xFA,0x6F,0xF6,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,
 328                   0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x60,0x06,0x5F,0xFA,0x3F,0xFC,
 329                   0x5F,0xFA,0x60,0x06,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,
 330                   0x70,0x0E,0x70,0x0E,0x70,0x0E,0x6F,0xF6,0x5F,0xFA,0x3F,0xFC,0x00,0x00,0x00,0x00},
 331                  
 332                  {// 图片数字9
 333                   0x00,0x00,0x3F,0xFC,0x5F,0xFA,0x6F,0xF6,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,
 334                   0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x60,0x06,0x5F,0xFA,0x3F,0xFC,
 335                   0x1F,0xFA,0x00,0x06,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,
 336                   0x00,0x0E,0x00,0x0E,0x00,0x0E,0x1F,0xF6,0x3F,0xFA,0x7F,0xFC,0x00,0x00,0x00,0x00},
 337                  
 338                  {// 温度符号
 339               0x00,0x00,0x00,0x00,0x70,0xE0,0x53,0xF0,0x77,0xFA,0x0E,0x0E,0x0C,0x06,0x18,0x06,
 340               0x18,0x02,0x38,0x02,0x30,0x00,0x30,0x00,0x70,0x00,0x60,0x00,0x60,0x00,0x60,0x00,
 341               0x60,0x00,0x60,0x00,0x70,0x00,0x30,0x00,0x30,0x00,0x38,0x00,0x18,0x02,0x18,0x02,
 342               0x0C,0x06,0x0E,0x06,0x07,0x0E,0x03,0xFA,0x00,0xF0,0x00,0x60,0x00,0x00,0x00,0x00}};
 343          
 344          
 345          
 346          
 347          
 348          /*===================== 显示模式3数字图片（宽度x高度=24*32）=========================*/
 349          
 350          uchar code mode_3num[10][96]={
 351                  {// 图片数字0
 352                   0x00,0x7E,0x00,0x01,0xE7,0x80,0x03,0xC3,0xC0,0x07,0x81,0xE0,0x0F,0x80,0xF0,0x0F,
 353                   0x00,0xF0,0x1F,0x00,0xF8,0x1E,0x00,0xF8,0x3E,0x00,0x78,0x3E,0x00,0x7C,0x3E,0x00,
 354                   0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,
 355                   0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,
 356                   0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x78,0x1E,0x00,0xF8,0x1F,0x00,0xF8,0x0F,0x00,
 357                   0xF0,0x0F,0x81,0xF0,0x07,0x81,0xE0,0x03,0xC3,0xC0,0x01,0xE7,0x80,0x00,0x7E,0x00},
 358          
 359                  {// 图片数字1
 360                   0x00,0x0C,0x00,0x00,0x1C,0x00,0x00,0x7C,0x00,0x07,0xFC,0x00,0x00,0x3C,0x00,0x00,
 361                   0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,
 362                   0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,
 363                   0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,
 364                   0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,
 365                   0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3E,0x00,0x00,0x7F,0x00,0x07,0xFF,0xF0},
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 7   

 366                                     
 367                  {// 图片数字2
 368                   0x00,0xFF,0x00,0x03,0xC7,0xC0,0x07,0x01,0xE0,0x0E,0x00,0xF0,0x1E,0x00,0xF8,0x1E,
 369                   0x00,0xF8,0x3E,0x00,0x78,0x3E,0x00,0x78,0x3F,0x00,0x78,0x3F,0x00,0x78,0x1F,0x00,
 370               0xF8,0x00,0x00,0xF8,0x00,0x00,0xF0,0x00,0x01,0xF0,0x00,0x03,0xE0,0x00,0x03,0xC0,
 371                   0x00,0x07,0x80,0x00,0x0F,0x00,0x00,0x1E,0x00,0x00,0x3C,0x00,0x00,0x78,0x00,0x00,
 372                   0xF0,0x00,0x01,0xE0,0x00,0x03,0xC0,0x00,0x07,0x80,0x1C,0x07,0x00,0x1C,0x0E,0x00,
 373                   0x38,0x1C,0x00,0x38,0x3C,0x00,0x78,0x3F,0xFF,0xF8,0x3F,0xFF,0xF8,0x3F,0xFF,0xF8},
 374          
 375                  {// 图片数字3
 376                   0x00,0xFE,0x00,0x07,0x87,0x80,0x0F,0x03,0xC0,0x1E,0x01,0xE0,0x1E,0x01,0xF0,0x1E,
 377                   0x01,0xF0,0x1F,0x00,0xF0,0x1F,0x00,0xF0,0x1E,0x00,0xF0,0x00,0x00,0xF0,0x00,0x01,
 378                   0xF0,0x00,0x01,0xF0,0x00,0x03,0xE0,0x00,0x03,0xC0,0x00,0x0F,0x00,0x00,0xFE,0x00,
 379                   0x00,0x07,0x80,0x00,0x01,0xE0,0x00,0x00,0xF0,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,
 380                   0x00,0x78,0x00,0x00,0x7C,0x1E,0x00,0x7C,0x3F,0x00,0x7C,0x3F,0x00,0x7C,0x3F,0x00,
 381                   0x78,0x3E,0x00,0xF8,0x1E,0x00,0xF0,0x0F,0x01,0xE0,0x07,0x87,0xC0,0x01,0xFF,0x00},
 382          
 383                  {// 图片数字4
 384                   0x00,0x03,0xC0,0x00,0x03,0xC0,0x00,0x07,0xC0,0x00,0x0F,0xC0,0x00,0x0F,0xC0,0x00,
 385                   0x1F,0xC0,0x00,0x3F,0xC0,0x00,0x3F,0xC0,0x00,0x77,0xC0,0x00,0x77,0xC0,0x00,0xE7,
 386                   0xC0,0x01,0xC7,0xC0,0x01,0xC7,0xC0,0x03,0x87,0xC0,0x07,0x07,0xC0,0x07,0x07,0xC0,
 387                   0x0E,0x07,0xC0,0x1E,0x07,0xC0,0x1C,0x07,0xC0,0x38,0x07,0xC0,0x38,0x07,0xC0,0x7F,
 388                   0xFF,0xFE,0x7F,0xFF,0xFE,0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,0x07,
 389                   0xC0,0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,0x07,0xC0,0x00,0x07,0xE0,0x00,0x7F,0xFE},
 390          
 391                  {// 图片数字5
 392                   0x0F,0xFF,0xF8,0x0F,0xFF,0xF8,0x0F,0xFF,0xF8,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,
 393                   0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,0x00,0x0E,0x00,
 394                   0x00,0x0E,0x7F,0x00,0x0D,0xFF,0xC0,0x0F,0xC3,0xE0,0x1F,0x01,0xF0,0x1E,0x00,0xF8,
 395                   0x1E,0x00,0xF8,0x00,0x00,0x78,0x00,0x00,0x7C,0x00,0x00,0x7C,0x00,0x00,0x7C,0x00,
 396                   0x00,0x7C,0x1E,0x00,0x7C,0x3F,0x00,0x7C,0x3F,0x00,0x78,0x3F,0x00,0x78,0x3E,0x00,
 397                   0xF8,0x1E,0x00,0xF0,0x1E,0x01,0xF0,0x0E,0x01,0xE0,0x07,0x87,0xC0,0x00,0xFF,0x00},
 398          
 399                  {// 图片数字6
 400                   0x00,0x3F,0xC0,0x00,0xF1,0xE0,0x03,0xC1,0xF0,0x07,0x81,0xF8,0x07,0x01,0xF8,0x0F,
 401                   0x00,0xF0,0x1F,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x3E,0x00,0x00,0x3E,0x00,
 402                   0x00,0x3E,0x00,0x00,0x3E,0x3F,0x80,0x3E,0xFF,0xE0,0x3F,0xE3,0xF0,0x3F,0x80,0xF8,
 403                   0x3F,0x00,0xF8,0x3F,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x7C,0x3E,0x00,0x3C,0x3E,
 404                   0x00,0x3C,0x3E,0x00,0x3C,0x3E,0x00,0x3C,0x3E,0x00,0x7C,0x1E,0x00,0x7C,0x1F,0x00,
 405                   0x78,0x0F,0x00,0x78,0x0F,0x80,0xF0,0x07,0xC0,0xE0,0x03,0xE3,0xC0,0x00,0xFF,0x00},
 406          
 407                  {// 图片数字7
 408                   0x1F,0xFF,0xFC,0x1F,0xFF,0xFC,0x1F,0xFF,0xF8,0x1F,0x00,0x38,0x1C,0x00,0x70,0x1C,
 409                   0x00,0xE0,0x38,0x00,0xE0,0x38,0x01,0xC0,0x00,0x01,0xC0,0x00,0x03,0x80,0x00,0x03,
 410                   0x80,0x00,0x07,0x80,0x00,0x07,0x00,0x00,0x0F,0x00,0x00,0x0E,0x00,0x00,0x1E,0x00,
 411                   0x00,0x1E,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x7C,0x00,0x00,
 412                   0x78,0x00,0x00,0x78,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,
 413                   0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0x78,0x00},
 414          
 415                  {// 图片数字8
 416                   0x00,0xFF,0x00,0x07,0xC3,0xC0,0x0F,0x00,0xE0,0x1E,0x00,0xF0,0x1E,0x00,0x78,0x3C,
 417                   0x00,0x78,0x3C,0x00,0x78,0x3C,0x00,0x7C,0x3E,0x00,0x78,0x3E,0x00,0x78,0x1F,0x00,
 418                   0x78,0x1F,0x80,0xF0,0x0F,0xE1,0xE0,0x07,0xFB,0xC0,0x01,0xFF,0x80,0x01,0xFF,0x80,
 419                   0x07,0xBF,0xC0,0x0F,0x0F,0xE0,0x1E,0x03,0xF0,0x3E,0x01,0xF8,0x3C,0x00,0xF8,0x3C,
 420                   0x00,0x7C,0x7C,0x00,0x7C,0x78,0x00,0x3C,0x78,0x00,0x3C,0x7C,0x00,0x3C,0x3C,0x00,
 421                   0x78,0x3C,0x00,0x78,0x1E,0x00,0x70,0x0F,0x00,0xE0,0x07,0xC3,0xC0,0x01,0xFF,0x00},
 422          
 423                  {// 图片数字9
 424                   0x01,0xFE,0x00,0x07,0xC7,0x80,0x0F,0x01,0xE0,0x1E,0x01,0xE0,0x1E,0x00,0xF0,0x3E,
 425                   0x00,0xF8,0x3C,0x00,0x78,0x3C,0x00,0x78,0x7C,0x00,0x7C,0x7C,0x00,0x7C,0x7C,0x00,
 426                   0x7C,0x7C,0x00,0x7C,0x7C,0x00,0x7C,0x3C,0x00,0xFC,0x3E,0x00,0xFC,0x3E,0x01,0xFC,
 427               0x1F,0x03,0xFC,0x1F,0x8F,0xFC,0x0F,0xFF,0x7C,0x03,0xFC,0x7C,0x00,0x00,0x7C,0x00,
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 8   

 428               0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF0,0x00,0x01,0xF0,0x0F,0x01,
 429                   0xE0,0x1F,0x01,0xE0,0x1F,0x03,0xC0,0x1F,0x07,0x80,0x0F,0x9F,0x00,0x03,0xFC,0x00}};
 430          
 431          
 432          
 433          
 434          /*========================== 标记及点图片（宽度x高度=16*16）===========================*/
 435          
 436          
 437          uchar code running[7][32]={
 438               {// 警报标记16*16
 439                    0x00,0x00,0x00,0x39,0x00,0x7B,0x00,0xFE,0x01,0xDC,0x0F,0x98,0x0F,0x18,0x0C,0x1F,
 440                0x0C,0x1F,0x0F,0x18,0x0F,0x98,0x01,0xDC,0x00,0xFE,0x00,0x7B,0x00,0x39,0x00,0x00,},
 441                   {// 闹铃开启标记16*16
 442                    0x00,0x00,0x00,0x40,0x00,0xE0,0x01,0xB0,0x01,0xB0,0x03,0x18,0x03,0x18,0x06,0x0C,
 443                0x0C,0x06,0x0C,0xE6,0x1B,0x1B,0x0C,0x06,0x06,0x0C,0x03,0xF8,0x00,0xE0,0x00,0x00},
 444                   {// 键盘锁标记16*16
 445                0x00,0x00,0x01,0xF8,0x03,0xFC,0x03,0x0C,0x03,0x0C,0x03,0x0C,0x03,0xFC,0x06,0x96,
 446                0x0E,0xA7,0x0E,0xC7,0x0E,0xA7,0x0E,0x97,0x07,0xFE,0x03,0xFC,0x01,0xF8,0x00,0x00,},
 447                   {// 温度计标记16*16
 448                    0x00,0x00,0x1F,0xF8,0x1F,0xF8,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,
 449                0x01,0x90,0x01,0x98,0x01,0x9C,0x01,0x9E,0x01,0x9C,0x00,0x18,0x00,0x10,0x00,0x00},
 450                   {// 模式3点16*16
 451                    0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,
 452                0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
 453                   {// 模式2点16*16
 454                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,
 455                0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},   
 456                   {// 篮球器运行标记16*16
 457                    0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xF8,0x1F,0xF8,0x01,0x80,0x01,0x80,0x01,0x90,
 458                0x01,0x98,0x01,0x9C,0x01,0x9E,0x01,0x9C,0x01,0x98,0x01,0x90,0x00,0x00,0x00,0x00}};
 459          
 460          
 461          /*========================== 菜单按钮图片（宽度x高度=16*8）============================*/
 462          
 463          uchar code menu_key[]=
 464                   {//菜单按钮
 465                    0x7F,0xFE,0x81,0x81,0x83,0xC1,0x87,0xE1,0x8F,0xF1,0x9F,0xF9,0x80,0x01,0x7F,0xFE};
 466          
 467          
 468          
 469          
 470          
 471          /*=====================================================================================
 472           函数名称：定时器中断处理与初始化，延时
 473           功能描述：时钟更新、篮球器计时
 474           全局变量：time_tick、time_tick1、resu[2]、resu[3]、resu[4]、temp_delay、temp_min
 475           参数说明：无
 476           返回说明：t0_isr(中断标记)、b20time(温度更新标记)
 477           设 计 人：LIJH
 478           版    本：1.0
 479           说    明：
 480           ======================================================================================*/
 481          
 482          
 483          /*延时（一次10个机器周期不等） 参数格式：延时数*/
 484          void delay(unsigned int det)
 485          {
 486   1        while(det--);
 487   1      }
 488          
 489          
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 9   

 490          
 491          /*1s延时*/
 492          void delay_pw()
 493          {
 494   1        delay(60000);
 495   1        delay(60000);
 496   1      }
 497          
 498          
 499          /*6个周期  6us */
 500          void  delay_b20(uchar n)
 501          {  
 502   1        while(n--);
 503   1      }
 504          
 505          
 506          
 507          /*主时钟中断处理*/
 508          void time0_isr(void) interrupt  TF0_VECTOR  using 1
 509          {
 510   1        TR0=0;
 511   1        TL0=(time_count&0x00FF);
 512   1        TH0=(time_count>>8);
 513   1        TR0=1;
 514   1        if(--time_tick)  return;
 515   1        time_tick=20;
 516   1        t0_isr=1;
 517   1        if(nba_tim&!oth_run)     // 当在篮球器界面时 nba_tim==1、oth_run==0 
 518   1        {
 519   2          if(resu[3]==0)
 520   2              {
 521   3                resu[3]=59;
 522   3                if(resu[2]>0) resu[2]--;
 523   3              }
 524   2              else resu[3]--;
 525   2              if(resu[2]==0&resu[3]==0)  // 比赛时间到后停止
 526   2              {
 527   3                TR0=0;TR1=0;EA=0;
 528   3              }
 529   2              return;
 530   2        }
 531   1        if((++temp_min)==60)    // 实现温度的更新
 532   1        {
 533   2          temp_min=0;
 534   2          temp_delay--;
 535   2              if(temp_delay==0)
 536   2          {
 537   3                b20time=1;temp_delay=5;
 538   3              }
 539   2        }     
 540   1      }
 541          
 542          
 543          /*24时钟中断处理*/
 544          void time1_isr(void) interrupt  TF1_VECTOR  using 2
 545          {
 546   1        TR1=0;
 547   1        TL1=(time_count&0x00FF);
 548   1        TH1=(time_count>>8);
 549   1        TR1=1;
 550   1        if(--time_tick1) return;
 551   1        time_tick1=20;
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 10  

 552   1        if(resu[4]>0)resu[4]--;         //  篮球器24秒中断
 553   1        t0_isr=1;
 554   1        if(resu[4]==0)
 555   1        { TR0=0;TR1=0;EA=0;}
 556   1      }
 557          
 558          
 559          /*定时器初始化*/
 560          void time_init()                        
 561          {
 562   1        EA=0;
 563   1        TR0=0;
 564   1        TR1=0;
 565   1        TMOD=0x11;
 566   1        TL0=(time_count&0x00FF);
 567   1        TH0=(time_count>>8);
 568   1        TL1=(time_count&0x00FF);
 569   1        TH1=(time_count>>8);
 570   1        IE=0;
 571   1        ET0=1;
 572   1        ET1=1;
 573   1      }
 574          
 575          
 576          
 577          /*=====================================================================================
 578           函数名称：LCD驱动
 579           功能描述：基本驱动（写1个字节、清屏、初始化）
 580           全局变量：无
 581           参数说明：dat_comm（0：命令 1：数据）,content（数值）
 582           返回说明：无返回值
 583           设 计 人：LIJH
 584           版    本：1.0
 585           说    明：
 586           ======================================================================================*/
 587          
 588          
 589          /*检查忙碌位*/
 590          void chk_busy (void)
 591          {
 592   1        lcd_data = 0xff;
 593   1        lcd_rs = 0;    // 命令
 594   1        lcd_rw = 1;    // 读
 595   1        lcd_e = 1;
 596   1        while(busy==1);
 597   1        lcd_e = 0;
 598   1      }
 599          
 600          
 601          /*写LCD 参数格式：0:命令,1:数值 ，数据*/
 602          void wr_lcd (uchar dat_comm,uchar content)
 603          {
 604   1        chk_busy ();
 605   1        lcd_rs=dat_comm;
 606   1        lcd_rw = 0;         // 写
 607   1        lcd_data=content;   // 输出数据或命令
 608   1        lcd_e=1;             
 609   1        lcd_e=0;
 610   1      }
 611          
 612          
 613          /*清绘图*/
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 11  

 614          void clrgdram(void)
 615          {
 616   1        uchar i,j;
 617   1        for(j=0;j<32;j++)
 618   1        {
 619   2          wr_lcd(comm,0x34);
 620   2          wr_lcd(comm,0x80+j);
 621   2          wr_lcd(comm,0x80);
 622   2          wr_lcd(comm,0x30);
 623   2          for(i=0;i<32;i++)
 624   2            wr_lcd(dat,0x00);  // 写入0x00
 625   2         }
 626   1        wr_lcd(comm,0x36);
 627   1      }
 628          
 629          
 630          /*清除显示*/
 631          void clear_dis(void)
 632          {
 633   1        wr_lcd(comm,0x30);
 634   1        wr_lcd(comm,0x01);  // 清屏，地址指针指向00H
 635   1        clrgdram();             // 请绘图RAM
 636   1      }
 637          
 638          
 639          
 640          /*开机LCD初始化*/
 641          void init_lcd (void)
 642          {
 643   1        lcd_rst=1;
 644   1        wr_lcd(comm,0x30);  // 30---基本指令动作  
 645   1        wr_lcd(comm,0x06);  // 光标的移动方向
 646   1        wr_lcd(comm,0x0c);  // 开显示，关游标
 647   1        clear_dis(); 
 648   1      }
 649          
 650          
 651          
 652          
 653          
 654          /*=====================================================================================
 655           函数名称：DS1302驱动
 656           功能描述：基本驱动（读写数据、读写日期，时间、初始化）
 657           全局变量：无
 658           参数说明：w_adder（写地址）,r_adder（读地址），w_data（写入数据）
 659           返回说明：返回读取的数据
 660           设 计 人：LIJH
 661           版    本：1.0
 662           说    明：上升沿写入数值，下降沿读出数值，没用设立后背电池充电
 663           ======================================================================================*/
 664          
 665          
 666          /*向1302写数据 参数格式：地址，数据*/
 667          void w1302(uchar w_adder,uchar w_data)
 668          {
 669   1        uchar d;
 670   1        ret_ds1302();
 671   1        for(d=0;d<16;d++)
 672   1        {
 673   2          if(d==8) w_adder=w_data;
 674   2              d02_data=(bit)(w_adder&0x01);
 675   2          d02_sclk=0;          // 上升沿
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 12  

 676   2          w_adder>>=1;
 677   2          d02_sclk=1;
 678   2        }
 679   1        end_ds1302();    
 680   1      }
 681          
 682          
 683          
 684          /*接收1302一个字节的数据 参数格式：读地址*/
 685          uchar r1302(uchar r_adder)
 686          {
 687   1        uchar d=0;
 688   1        ret_ds1302();
 689   1        for(d=0;d<8;d++)       // 写地址
 690   1        {
 691   2          d02_data=(bit)(r_adder&0x01);
 692   2          d02_sclk=0;
 693   2          r_adder>>=1;
 694   2          d02_sclk=1;
 695   2        }
 696   1        r_adder=0;
 697   1        for(d=0;d<8;d++)       // 读数据 
 698   1        {
 699   2              d02_data=1;
 700   2              d02_sclk=1;              // 下降沿
 701   2              r_adder>>=1;
 702   2              d02_sclk=0;
 703   2              if(d02_data) r_adder|=0x80;
 704   2        }
 705   1        end_ds1302();
 706   1        return(r_adder);
 707   1      }
 708          
 709          
 710          
 711          /*写入时间与日期*/
 712          void wds1302_time_date(void)
 713          {
 714   1        w1302(d02_wrc,0x00);                           // 写允许
 715   1        w1302(0x90,0xa5);                  // 单二极管2K电阻充电
 716   1        w1302(d02_year,today.year);            // 年
 717   1        w1302(d02_weeks,today.week);           // 星期
 718   1        w1302(d02_month,today.month);          // 月
 719   1        w1302(d02_day,today.day);              // 日
 720   1        w1302(d02_hour,0x7f&now.hour);         // 时
 721   1        w1302(d02_minute,now.minute);          // 分
 722   1        w1302(d02_second,0x7f&now.second); // 秒
 723   1        w1302(d02_wrc,0x80);                           // 写禁止
 724   1      }
 725          
 726          
 727          
 728          
 729          /*初始化写DS1302 RAM*/
 730          void init_wds1302_ram(void)
 731          {
 732   1        w1302(d02_wrc,0x00); 
 733   1        w1302(0x90,0xa5);         // 单二极管2K电阻充电
 734   1        w1302(d02_signs,0x00);        // 状态寄存
 735   1        w1302(d02_passw,0x74);        // 密码储存首位
 736   1        w1302(d02_passw+2,0x14);  // 初始值为:741456
 737   1        w1302(d02_passw+4,0x56);  // 密码最后一位
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 13  

 738   1        w1302(d02_alm,0x12);          // 闹铃时(12小时)
 739   1        w1302(d02_alm+2,0x00);        // 闹铃分(0分)
 740   1        w1302(d02_temp,0xff);         // 温度上限(255为关闭)   
 741   1        w1302(d02_temp+2,0xff);   // 温度下限(关闭)
 742   1        w1302(d02_initsi,0xb4);   // 是否要初始化标记(0xb4为已经初始化)
 743   1        w1302(d02_wrc,0x80); 
 744   1      }
 745          
 746          /*写DS1302一字节的RAM*/
 747          void wds1302_data(uchar adder,uchar _data)
 748          {
 749   1        w1302(d02_wrc,0x00); 
 750   1        w1302(adder,_data);
 751   1        w1302(d02_wrc,0x80);
 752   1      } 
 753          
 754          
 755          /*读取日期*/
 756          void rds1302_date(void)
 757          {
 758   1        
 759   1        today.year=r1302(d02_year+1);   
 760   1        today.week=r1302(d02_weeks+1);
 761   1        today.month=r1302(d02_month+1);
 762   1        today.day=r1302(d02_day+1);  
 763   1      }
 764          
 765          
 766          /*读取时间*/
 767          void rds1302_time(void)
 768          {
 769   1        now.hour=(r1302(d02_hour+1));
 770   1        now.minute=r1302(d02_minute+1);
 771   1        now.second=r1302(d02_second+1);
 772   1        if(now.hour==alarm_time[0]&&now.minute==alarm_time[1]) alm_run=1;
 773   1        else                                                                          // 闹铃时间比较
 774   1        {
 775   2          alm_run=0;buzstop=0;buzzer=close;
 776   2        } 
 777   1      }                                       
 778          
 779          /*开机读数据*/
 780          void rds1302_data(void)
 781          {
 782   1        signs=r1302(d02_signs+1);
 783   1        alarm_time[0]=r1302(d02_alm+1);
 784   1        alarm_time[1]=r1302(d02_alm+3);
 785   1        als_temp[0]=r1302(d02_temp+1);
 786   1        als_temp[1]=r1302(d02_temp+3);                   
 787   1      }
 788           
 789          
 790          /*DS1302初始化*/
 791          void init_ds1302(void)
 792          {
 793   1        wds1302_time_date();
 794   1        init_wds1302_ram();
 795   1      }
 796          
 797          
 798          /*=====================================================================================
 799           函数名称：DS18b20驱动
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 14  

 800           功能描述：基本驱动（读写数据、数据转换、初始化）
 801           全局变量：无
 802           参数说明：无
 803           返回说明：返回读取的数据
 804           设 计 人：LIJH
 805           版    本：1.0
 806           说    明：调试中。。。
 807           ======================================================================================*/
 808          
 809          
 810          
 811          /*18B20初始化*/
 812          void init_ds18b20()
 813          {
 814   1        b20_io=1;
 815   1        b20_io=0;
 816   1        delay_b20(120);               // 延时≥480us
 817   1        b20_io=1;
 818   1        delay_b20(12);            // 拉高为高电平后在15―60us出现低电平，并维持60―240us
 819   1        ds18b20=~b20_io;
 820   1        delay_b20(40);        
 821   1      }
 822          
 823          
 824          /*向18B20发送一个字节*/
 825          void send18b20_byte(uchar data_send)
 826          {
 827   1        uchar d=0;
 828   1        for (d=0;d<8;d++)
 829   1        {
 830   2              b20_io=0;                                       // 拉低电平后向总线写入一个位，15us后18B20接收  
 831   2          b20_io=data_send&0x01;          
 832   2          delay_b20(10);                              // 延时60us后完成一次
 833   2          b20_io=1;
 834   2          data_send>>=1;                          // 下位开始
 835   2        }
 836   1      }
 837          
 838          
 839          /*从18B20读出温度值 12位分辨率*/  
 840          void receive18b20(void)
 841          {
 842   1        uchar n=1,d;
 843   1        for (d=0;d<16;d++)
 844   1        {
 845   2              if(d==8) n=0;
 846   2              b20_io=0;                                         // 拉低总线
 847   2              temp.t_data[n]>>=1;            
 848   2              b20_io=1;                     // 拉高总线
 849   2              if(b20_io)                                        // 读入总线数值
 850   2            temp.t_data[n]|=0x80;
 851   2          delay_b20(10);                                // 等待60us
 852   2        }
 853   1      }
 854          
 855          
 856          /*数据转化*/
 857          void conversion_t(void)
 858          {
 859   1        uchar save=0,save1=0;
 860   1        if(temp.temp_data<0)           // 判断数值符号
 861   1          {temp_pn=1;temp.temp_data=~temp.temp_data+1;}
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 15  

 862   1        else temp_pn=0;
 863   1        if(temp.t_data[1]&0x01==1) save+=6;       // 小数点后的值转变
 864   1        if((temp.t_data[1]>>1)&0x01==1) save+=12;
 865   1        if((temp.t_data[1]>>2)&0x01==1) save+=25;
 866   1        if((temp.t_data[1]>>3)&0x01==1) save+=50;
 867   1        temp.temp_data>>=4;
 868   1        save1=temp.temp_data&0x00ff;                          // 整数部分数值
 869   1        temp.t_data[0]=save1;
 870   1        temp.t_data[1]=save;
 871   1        thl_als=1;
 872   1        if(save1>=(als_temp[0]&0x7f))      // 温度比较
 873   1        {
 874   2              if(!temp_pn||(temp_pn&(als_temp[0]&0x80)!=0)){ als_th=open;als_tl=close;}
 875   2        }
 876   1        else if(save1<(als_temp[1]&0x7f)&&als_temp[1]!=255)
 877   1        {
 878   2          if(!temp_pn||(temp_pn&(als_temp[1]&0x80)!=0)) {als_tl=open;als_th=close;}
 879   2        }
 880   1        else {als_th=als_tl=close;thl_als=0;buzstop=0;buzzer=close;} 
 881   1      }
 882          
 883          
 884          
 885          /*18b20功能*/
 886          void ds18b20_func(void)
 887          {
 888   1        EA=0;
 889   1        TR0=0;
 890   1        temp.temp_data=0;
 891   1        init_ds18b20(); 
 892   1        send18b20_byte(0xcc); // 跳过ROM
 893   1        send18b20_byte(0x44); // 温度转换
 894   1        delay_pw();
 895   1        init_ds18b20();
 896   1        send18b20_byte(0xcc); 
 897   1        send18b20_byte(0xbe); // 读RAM
 898   1        receive18b20();               // 读取温度值
 899   1        conversion_t();               // 数值转换
 900   1        EA=1;
 901   1        TR0=1;
 902   1      }
 903          
 904          
 905          
 906          /*=====================================================================================
 907           函数名称：画面构造
 908           功能描述：界面1、2、3，图片菜单，反白，标头，16*16（32）图片
 909           全局变量：无
 910           参数说明：函数说明
 911           返回说明：无
 912           设 计 人：LIJH
 913           版    本：1.0
 914           说    明：X坐标每一格每次16点
 915           ======================================================================================*/
 916          
 917          
 918          /*反白或显示图片 参数格式：(H)8bit数据，(L)8bit数据,X0坐标(16bit)，Y0坐标(1bit),X坐标(16bit)，Y坐标(1bit)*
             -/
 919          void con_disp (uchar data1,uchar data2,uchar x0,uchar y0,uchar xl,uchar yl)
 920          {
 921   1        uchar i,j;
 922   1        for(j=0;j<yl;j++)
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 16  

 923   1        {
 924   2          for(i=0;i<xl;i++)
 925   2          {
 926   3            wr_lcd(comm,0x34);     // 扩展功能
 927   3            wr_lcd(comm,y0+j);         // 写Y坐标
 928   3            wr_lcd(comm,x0+i);         // 写X坐标
 929   3            wr_lcd(comm,0x30);         // 普通功能
 930   3            wr_lcd(dat,data1);
 931   3            wr_lcd(dat,data2);
 932   3          }
 933   2        }
 934   1        wr_lcd(comm,0x36);             // 开绘图显示
 935   1      }
 936          
 937          
 938          
 939          /*显示字体 参数格式: 显示位置(0x80-0x9f),显示个数，显示内容指针*/
 940          void display_cnasc(uchar dis_bit,uchar num,uchar *cnasc)
 941          {
 942   1        wr_lcd(comm,0x30);         // 普通功能
 943   1        wr_lcd(comm,dis_bit);      // 写地址
 944   1        while(num>0)
 945   1        {
 946   2          wr_lcd(dat,*(cnasc++));
 947   2          wr_lcd(dat,*(cnasc++));
 948   2              num--; 
 949   2        }
 950   1      }
 951          
 952          
 953          
 954          /*导航标头显示*/
 955          void dis_title(void)
 956          {
 957   1        display_cnasc(0x80,1,"\x15 ");
 958   1        display_cnasc(0x90,1,"┏");
 959   1        display_cnasc(0x97,1,"┓");
 960   1        display_cnasc(0x98,1,"┗");
 961   1        display_cnasc(0x9f,1,"┛");
 962   1        display_cnasc(0x92,1,"\x1e ");
 963   1        display_cnasc(0x9a,1,"\x1f ");
 964   1        con_disp(0xff,0xff,0x80,0x80,3,16);
 965   1        con_disp(0xef,0xef,0x83,0x80,1,16);
 966   1        con_disp(0xde,0xf7,0x84,0x80,1,16);
 967   1        con_disp(0x76,0xdb,0x85,0x80,1,16);
 968   1        con_disp(0x55,0x55,0x86,0x80,1,16);
 969   1        con_disp(0x55,0x55,0x87,0x80,1,16);   
 970   1      }
 971          
 972          
 973          /*图片显示标头*/
 974          void dis_title_pic(void)
 975          {
 976   1        display_cnasc(0x80,2,"〓〓");
 977   1        display_cnasc(0x86,2,"〓〓");
 978   1      }
 979          
 980          
 981          /*功能实现显示标头*/
 982          void dis_title_e(void)
 983          {
 984   1        display_cnasc(0x80,1," \x15");
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 17  

 985   1        con_disp(0xff,0xff,0x80,0x80,1,16);
 986   1        con_disp(0xff,0xc7,0x81,0x80,1,16);
 987   1        con_disp(0xff,0xff,0x82,0x80,3,16);
 988   1        con_disp(0xe3,0xff,0x85,0x80,1,16);
 989   1        con_disp(0xff,0xff,0x86,0x80,2,16);
 990   1      }
 991          
 992          
 993          
 994          /*显示菜单图片  格式：图片反显(1)或正常显示(0)，显示图片的号码*/
 995          void anti_nor_pic (uchar cpl_sign,uchar menu_num)
 996          {
 997   1        uchar i,j,x,y;
 998   1        x=menu_num*3;    // 计算图片显示坐标
 999   1        if(x>6) x--;
1000   1        if(menu_num<3) y=16;  // 上下半屏显示
1001   1        else y=8;
1002   1        if(cpl_sign==1) display_cnasc(0x82,4,menu_cn[menu_num]);
1003   1        for(j=0;j<24;j++)
1004   1        {
1005   2         for(i=0;i<2;i++)
1006   2         {
1007   3           wr_lcd(comm,0x34);
1008   3           wr_lcd(comm,0x80+y);
1009   3           wr_lcd(comm,0x80+x+i);  // 分两次显示 16bit
1010   3           wr_lcd(comm,0x30);
1011   3           if(cpl_sign==1)          // 图片反选
1012   3           {
1013   4                 wr_lcd(dat,~menu_pic[menu_num][j*4+i*2]);
1014   4             wr_lcd(dat,~menu_pic[menu_num][j*4+i*2+1]);
1015   4               }
1016   3           else                                         // 正常显示
1017   3           {
1018   4                 wr_lcd(dat,menu_pic[menu_num][j*4+i*2]);
1019   4             wr_lcd(dat,menu_pic[menu_num][j*4+i*2+1]);
1020   4               }
1021   3         }
1022   2         y++;
1023   2         if(y==32&&menu_num<3) {x+=8;y=0;}  // 上下屏切换
1024   2        }
1025   1        wr_lcd(comm,0x36);
1026   1      }
1027          
1028          
1029          
1030          
1031          /*状态16*16图片  格式：反色（1）或正常0，X坐标，Y坐标，状态编码（16*16）*/
1032          void dis_run_state(uchar cpl,uchar x0,uchar y0,uchar state_num)
1033          {
1034   1        uchar j;
1035   1        for(j=0;j<16;j++)
1036   1        {
1037   2          wr_lcd(comm,0x34);  // 扩展功能
1038   2          wr_lcd(comm,y0++);  // 写Y地址
1039   2          wr_lcd(comm,x0);    // 写X地址
1040   2          wr_lcd(comm,0x30);  // 普通功能
1041   2              if(cpl==1)                      // 写数据
1042   2          {
1043   3                wr_lcd(dat,~running[state_num][j*2]);
1044   3            wr_lcd(dat,~running[state_num][j*2+1]);
1045   3              }
1046   2              else
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 18  

1047   2              {
1048   3                wr_lcd(dat,running[state_num][j*2]);
1049   3            wr_lcd(dat,running[state_num][j*2+1]);
1050   3              }
1051   2        }
1052   1        wr_lcd(comm,0x36);
1053   1      }
1054          
1055           
1056          
1057           /*显示菜单按钮  参数格式：反色(1)或正常(0)*/
1058          void dis_menu_key(uchar d)
1059          {
1060   1        if(d==1)
1061   1        {
1062   2          for(d=0;d<8;d++)                                                              // 显示菜单按钮
1063   2            con_disp(~menu_key[d*2],~menu_key[d*2+1],0x9f,0x97+d,1,1);
1064   2        }
1065   1        else
1066   1        {
1067   2          for(d=0;d<8;d++)                                                              // 显示菜单按钮
1068   2            con_disp(menu_key[d*2],menu_key[d*2+1],0x9f,0x97+d,1,1);
1069   2        }
1070   1      }
1071          
1072          
1073          
1074          
1075          /*显示模式3的界面*/
1076          void dis_mode3(void)
1077          {
1078   1        uchar i,j,h,l,x_0=0x80,y_0=0x90;
1079   1        h=now.hour>>4;       // 分离十位 个位
1080   1        l=now.hour&0x0f;
1081   1        for(j=0;j<2;j++)
1082   1        {
1083   2          for(i=0;i<32;i++)  // 十位个位一起读入
1084   2          { 
1085   3            wr_lcd(comm,0x34);
1086   3            wr_lcd(comm,y_0++);
1087   3            wr_lcd(comm,x_0);
1088   3            wr_lcd(comm,0x30);
1089   3            wr_lcd(dat,mode_3num[h][i*3]);  // 连续写数据，X坐标自动加1
1090   3            wr_lcd(dat,mode_3num[h][i*3+1]);
1091   3            wr_lcd(dat,mode_3num[h][i*3+2]);
1092   3            wr_lcd(dat,mode_3num[l][i*3]);
1093   3            wr_lcd(dat,mode_3num[l][i*3+1]);
1094   3            wr_lcd(dat,mode_3num[l][i*3+2]); 
1095   3            if(y_0==0xa0){x_0=x_0+8;y_0=0x80;}
1096   3          }
1097   2          x_0=0x84,y_0=0x90;
1098   2          h=now.minute>>4;   // 分离十位 个位
1099   2          l=now.minute&0x0f;
1100   2        }
1101   1        dis_run_state(0,0x83,0x90,4); // 显示点
1102   1        dis_run_state(0,0x8b,0x80,4);                                    
1103   1        y_0=0x80;                        // 显示状态标记
1104   1        if(keb) {dis_run_state(0,0x87,y_0,2);y_0+=16;}
1105   1        if(alm) {dis_run_state(0,0x87,y_0,1);y_0+=16;}
1106   1        if(y_0<0xa0&&!als){dis_run_state(0,0x87,y_0,0);}
1107   1        if(y_0==0xa0&&!als){dis_run_state(0,0x8f,0x80,0);}
1108   1        dis_menu_key(0);
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 19  

1109   1      }
1110          
1111          
1112          
1113          
1114          /*显示模式1和2的共用部分*/
1115          void mode1_2_union(void)
1116          {
1117   1        uchar x=0x9b;
1118   1        display_cnasc(0x98,2,"星期");
1119   1        if(nba_tim) dis_run_state(0,x,0x90,6);
1120   1        if(keb) {dis_run_state(0,x,0x90,2);x++;}    // 显示标记
1121   1        if(alm) {dis_run_state(0,x,0x90,1);x++;}
1122   1        if(!als){dis_run_state(0,x,0x90,0);}
1123   1        dis_menu_key(0);                           // 显示菜单按钮
1124   1      }
1125          
1126          
1127          /*显示模式2的日期*/
1128          void dis_date_mode2(uchar d)
1129          {
1130   1        uchar save[2];
1131   1        display_cnasc(d+2,1,"年");
1132   1        display_cnasc(d+4,1,"月");
1133   1        display_cnasc(d+6,1,"日");
1134   1        display_cnasc(0x9a,1,weeks[today.week]);  // 显示星期
1135   1        save[0]=char_num[today.year>>4];              // 将显示的数值存到数组中
1136   1        save[1]=char_num[today.year&0x0f];
1137   1        display_cnasc(d+1,1,save);
1138   1        save[0]=char_num[today.month>>4];
1139   1        save[1]=char_num[today.month&0x0f];
1140   1        display_cnasc(d+3,1,save);
1141   1        save[0]=char_num[today.day>>4];
1142   1        save[1]=char_num[today.day&0x0f];
1143   1        display_cnasc(d+5,1,save);
1144   1      }
1145          
1146          /*显示模式2的时间数字显示  16*32*/
1147          void num2_asc_dis(uchar num,uchar x_0)
1148          {
1149   1        uchar i,y_0=0x90;
1150   1        for(i=0;i<32;i++)  // 十位个位一起读入
1151   1        { 
1152   2          wr_lcd(comm,0x36);
1153   2          wr_lcd(comm,y_0++);
1154   2          wr_lcd(comm,x_0);
1155   2          wr_lcd(comm,0x30);
1156   2          wr_lcd(dat,mode_2num[num][i*2]);
1157   2          wr_lcd(dat,mode_2num[num][i*2+1]);
1158   2              if(i==15){x_0+=8;y_0=0x80;}
1159   2        }
1160   1        wr_lcd(comm,0x36);
1161   1      }
1162          
1163          /*显示模式2的时间*/
1164          void dis_time_mode2(void)
1165          {
1166   1        uchar h,l;
1167   1        if(now.hour!=save_time.hour||init_d2)
1168   1        {
1169   2          h=now.hour>>4;    // 分离十位 个位
1170   2          l=now.hour&0x0f;
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 20  

1171   2          num2_asc_dis(h,0x80);
1172   2              num2_asc_dis(l,0x80+1);
1173   2        }
1174   1        if(now.minute!=save_time.minute||init_d2)
1175   1        {
1176   2          h=now.minute>>4;    // 分离十位 个位
1177   2          l=now.minute&0x0f;
1178   2          num2_asc_dis(h,0x83); 
1179   2              num2_asc_dis(l,0x83+1);
1180   2        }
1181   1        if(now.second!=save_time.second||init_d2)
1182   1        {
1183   2          h=now.second>>4;    // 分离十位 个位
1184   2          l=now.second&0x0f;
1185   2          num2_asc_dis(h,0x86);
1186   2              num2_asc_dis(l,0x86+1);
1187   2        }
1188   1        if(init_d2)
1189   1        {
1190   2          dis_run_state(0,0x82,0x90,5); // 显示点
1191   2          dis_run_state(0,0x8a,0x80,5);
1192   2          dis_run_state(0,0x85,0x90,5); // 显示点
1193   2          dis_run_state(0,0x8d,0x80,5);
1194   2        }     
1195   1      }
1196          
1197          
1198          /*显示模式2的界面*/
1199          void dis_mode2(void)
1200          {
1201   1        dis_date_mode2(0x81);       // 显示日期
1202   1        display_cnasc(0x81,1,"20");
1203   1        dis_time_mode2();                       // 显示时间
1204   1        mode1_2_union();
1205   1      }
1206          
1207          
1208          /*显示模式1的日期*/
1209          void dis_date_mode1(void)
1210          {
1211   1        uchar save[2];
1212   1        display_cnasc(0x80,3,"日期："); 
1213   1        display_cnasc(0x90,3,"时间："); 
1214   1        display_cnasc(0x88,3,"温度：");
1215   1        display_cnasc(0x9a,1,weeks[today.week]);  // 显示星期
1216   1        display_cnasc(0x83,1,"20");
1217   1        save[0]=char_num[today.year>>4];                        
1218   1        save[1]=char_num[today.year&0x0f];
1219   1        display_cnasc(0x84,1,save);
1220   1        save[0]='/';
1221   1        save[1]=char_num[today.month>>4];
1222   1        display_cnasc(0x85,1,save);
1223   1        save[0]=char_num[today.month&0x0f];
1224   1        save[1]='/';
1225   1        display_cnasc(0x86,1,save);
1226   1        save[0]=char_num[today.day>>4];
1227   1        save[1]=char_num[today.day&0x0f];
1228   1        display_cnasc(0x87,1,save);
1229   1        mode1_2_union();
1230   1      }
1231          
1232          
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 21  

1233          /*显示模式1的时间*/
1234          void dis_time_mode1(void)
1235          {
1236   1        uchar save[2];
1237   1        save[0]=char_num[now.hour>>4];
1238   1        save[1]=char_num[now.hour&0x0f];
1239   1        display_cnasc(0x93,1,save);
1240   1        save[0]=':';
1241   1        save[1]=char_num[now.minute>>4];
1242   1        display_cnasc(0x94,1,save);
1243   1        save[0]=char_num[now.minute&0x0f];
1244   1        save[1]=':';
1245   1        display_cnasc(0x95,1,save);
1246   1        save[0]=char_num[now.second>>4];
1247   1        save[1]=char_num[now.second&0x0f];
1248   1        display_cnasc(0x96,1,save);
1249   1      }
1250          
1251          
1252          /*显示模式1的温度*/
1253          void dis_temp_mode1(void)
1254          {
1255   1        uchar save[2];
1256   1        if(ds18b20)
1257   1        {
1258   2               if(temp.t_data[0]>99)
1259   2               {
1260   3                  save[0]=char_num[temp.t_data[0]/100];
1261   3                      save[1]=char_num[(temp.t_data[0]/10)%10];
1262   3                      display_cnasc(0x8b,1,save);
1263   3                      save[0]=char_num[temp.t_data[0]%10];
1264   3                      save[1]='.';
1265   3                      display_cnasc(0x8c,1,save);
1266   3                      save[0]=char_num[temp.t_data[1]/10];
1267   3                      save[1]=' ';
1268   3                      display_cnasc(0x8d,1,save);
1269   3                      display_cnasc(0x8e,1,"℃");
1270   3                }
1271   2                else
1272   2                {
1273   3              if(temp_pn) display_cnasc(0x8a,1,":-");
1274   3                  else  display_cnasc(0x8a,1,"：");
1275   3                      save[0]=char_num[temp.t_data[0]/10];
1276   3                      save[1]=char_num[temp.t_data[0]%10];
1277   3                      display_cnasc(0x8b,1,save);
1278   3                      save[0]='.';
1279   3                      save[1]=char_num[temp.t_data[1]/10];
1280   3                      display_cnasc(0x8c,1,save);
1281   3                      display_cnasc(0x8d,1,"℃");
1282   3                }
1283   2              }
1284   1        else display_cnasc(0x8b,3,"FF.F℃");
1285   1      }
1286          
1287          
1288          
1289          /*显示模式1的界面*/
1290          void dis_mode1(void)
1291          {
1292   1        dis_date_mode1(); 
1293   1        dis_time_mode1();
1294   1        dis_temp_mode1();
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 22  

1295   1      }
1296          
1297          
1298          
1299          /*篮球器时间显示*/
1300          void nba_dis_time(void)
1301          {
1302   1        uchar d,dis[2];
1303   1        for(d=2;d<4;d++)
1304   1        {
1305   2              dis[0]=char_num[resu[d]/10];
1306   2              dis[1]=char_num[resu[d]%10];
1307   2              display_cnasc(0x81+d*2,1,dis);
1308   2        }
1309   1        display_cnasc(0x86,1,": ");
1310   1        if(resu[0]==1)
1311   1        {
1312   2              dis[0]='\x07';
1313   2              dis[1]=char_num[resu[4]/10];
1314   2              display_cnasc(0x93,1,dis);
1315   2              dis[1]='\x07';
1316   2              dis[0]=char_num[resu[4]%10];
1317   2              display_cnasc(0x94,1,dis);
1318   2        }
1319   1      }
1320          
1321          
1322          /*=====================================================================================
1323           函数名称：键盘扫描
1324           功能描述：读取键盘操作数据及部分状态的实现
1325           全局变量：dis_sig  t0_isr  temprun  b20time  alm_run als_temp   buzstop  als
1326                     lock_op  nba_tim 
1327           参数说明：无
1328           返回说明：键盘锁与密码锁时间到达后返回 255
1329           设 计 人：LIJH
1330           版    本：1.0
1331           说    明：
1332           ======================================================================================*/
1333          
1334          /*扫描键盘*/
1335          uchar  keypad_scan()
1336          {
1337   1        uchar key,dis[2];
1338   1        keyboard=0xf0;
1339   1        while (keyboard==0xf0)     // 等待按键按下
1340   1        {      
1341   2       
1342   2        /*--------------------- 背光灯关闭延时 -----------------------*/
1343   2              
1344   2              delay(1000);                                 
1345   2              if((++dis[0])==0&&bl_delay!=0) bl_delay--;  // 当有按键按下bl_delay重新赋值     
1346   2              if(bl_delay==0&&!bl0) lcd_bl=close;         // 背光时间到且不是常开模式时关闭背光
1347   2      
1348   2                
1349   2        /*----------------------- 键盘锁延时 -------------------------*/      
1350   2      
1351   2              if(keb&&dis_sig&&bl_delay==0&&resu[11]<2) resu[11]++; // 当有按键按下j清零
1352   2              if(bl_delay==0) bl_delay=15; 
1353   2      
1354   2      
1355   2        /*--------------------- 密码锁30秒锁延时 ---------------------*/              
1356   2      
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 23  

1357   2              if(lock_op)                                      
1358   2              {
1359   3                if((++i)==0) save1++;         
1360   3                if(save1==15) return(255);
1361   3              }
1362   2              
1363   2      
1364   2        /*---------------------- 时钟界面时间显示 ---------------------*/
1365   2              
1366   2              if(dis_sig&&t0_isr||nba_tim&&oth_run)     // 正常时钟界面与篮球器返回时钟界面显示
1367   2          {    
1368   3                rds1302_date();           // 读出日期 
1369   3            rds1302_time();           // 读出时间
1370   3                if(di0)                   // 模式2
1371   3                {
1372   4                  dis_time_mode2(); 
1373   4                      if(now.hour==0&&now.minute==0&&now.second==0)   dis_date_mode2(0x81); 
1374   4                }
1375   3            else if(di1)                      // 模式3
1376   3                { 
1377   4                  if(now.hour!=save_time.hour||now.minute!=save_time.minute)   // 时,分变化后显示
1378   4                    dis_mode3();         
1379   4            }
1380   3            else 
1381   3                {
1382   4                  dis_time_mode1();   // 模式1
1383   4                  if(now.hour==0&&now.minute==0&&now.second==0) dis_date_mode1();
1384   4                }
1385   3                save_time=now;        // 重新记录作下次比较
1386   3                t0_isr=0;
1387   3              }
1388   2        
1389   2        
1390   2        /*-------------------- 温度计提示按键操作 ----------------------*/
1391   2              
1392   2              if(temprun)
1393   2              {
1394   3                if(!oth_run)
1395   3                {
1396   4                  display_cnasc(0x96,2," key");    // 温度计时提示按键操作
1397   4                      for(dis[1]=0;dis[1]<250;dis[1]++)
1398   4                  {
1399   5                    delay(1000);
1400   5                        if(keyboard!=0xf0)
1401   5                        {
1402   6                          keyboard=0x7f;
1403   6                              if(keyboard==0x7d) return 0x7d;
1404   6                              else  keyboard=0xf0;
1405   6                        }
1406   5                  }
1407   4                      oth_run=1;
1408   4                      display_cnasc(0x96,2,"    ");
1409   4                }
1410   3              }
1411   2        
1412   2        
1413   2         /*------------------------ 蜂鸣器警报 --------------------------*/
1414   2      
1415   2              
1416   2              if(((alm_run&&alm)||thl_als)&&!buzstop) // 温度，闹铃蜂鸣器警报
1417   2              {                                                                           // 有按键按下时停止
1418   3                if(now.second==0)     lcd_bl=close;
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 24  

1419   3                delay(15000);                                                 // 读出温度时间比较
1420   3                if(keyboard!=0xf0) break;
1421   3                delay(15000);
1422   3                if(keyboard!=0xf0) break;
1423   3                delay(15000);
1424   3                if(keyboard!=0xf0) break;
1425   3                delay(15000);
1426   3                if(alm_run)  lcd_bl=!lcd_bl;                  // 只在闹铃功能闪
1427   3                if(!als)buzzer=!buzzer;               // 警报开启后蜂鸣器开启                     
1428   3              } 
1429   2      
1430   2      
1431   2        /*----------------------- 温度刷新显示 -------------------------*/
1432   2      
1433   2              
1434   2              if((temprun&&oth_run)||(b20time&&!di0&&!di1&&dis_sig))    // 温度计功能于模式1界面 
1435   2          {  
1436   3               
1437   3                  ds18b20_func();                                               // 温度检测功能
1438   3                      oth_run=0;                                // 作交替标记用
1439   3                  if(temprun) return 20;                            // 温度计开启后返回
1440   3                  if(b20time){ dis_temp_mode1();b20time=0;} // 时钟界面5分钟更新一次，T0计时
1441   3          } 
1442   2      
1443   2        
1444   2         
1445   2         /*------------------------ 篮球器显示时间 ------------------------*/
1446   2              
1447   2              if(nba_tim&!oth_run)        // 当篮球器模式下 oth_run==0为篮球器计时状态 
1448   2              {
1449   3                if(EA) display_cnasc(0x8b,2," R\x10 ");  // 显示运行状态
1450   3                else  display_cnasc(0x8b,2," S! ");
1451   3                if(t0_isr)
1452   3                {                                                                                // 更新时间
1453   4                  nba_dis_time();
1454   4                      if(resu[2]==0&&resu[3]==0)                         // 判断比赛情况 
1455   4                      {
1456   5                        resu[6]++;
1457   5                        if(resu[6]<resu[1])  display_cnasc(0x85,3,"休息  ");
1458   5                        else  display_cnasc(0x85,3,"完结  ");
1459   5                      }
1460   4                      if(resu[4]==0||(resu[2]==0&&resu[3]==0))  // 时间到达警报
1461   4                  {
1462   5                     buzzer=open;
1463   5                     delay_pw();
1464   5                         if(resu[2]==0&&resu[3]==0)  // 24秒 总时间警报
1465   5                         {
1466   6                           delay_pw();
1467   6                         }
1468   5                     buzzer=close;
1469   5                         if(resu[4]==0) resu[4]=24;  // 重新赋值
1470   5                  }
1471   4                  t0_isr=0;                                      // 清零等下次中断产生
1472   4                }
1473   3              }
1474   2        }
1475   1      
1476   1                                
1477   1                                      /*===== 以上等待按键 =====*/
1478   1      
1479   1      
1480   1      
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 25  

1481   1        /*------------------------- 按键按下后 --------------------------*/
1482   1      
1483   1        
1484   1        delay(8000);               // 消抖振
1485   1        if(!lock_op)bl_delay=15;   // 背光时间赋值 
1486   1        if(bl1) lcd_bl=close;      // 不在背光灯关闭时亮起
1487   1        else lcd_bl=open;
1488   1        if(alm_run|thl_als) {buzstop=1;buzzer=close;}
1489   1        if(keb&&dis_sig) 
1490   1        {
1491   2          if(resu[11]==2) return 255;  // 要求输入密码        
1492   2              else resu[11]=0;                         // 时间不到时重新计时
1493   2        }
1494   1        do
1495   1        {     
1496   2              for(dis[0]=0;dis[0]<=3;dis[0]++)
1497   2          {
1498   3            keyboard=ksp[dis[0]];
1499   3                if(keyboard!=ksp[dis[0]])
1500   3            { 
1501   4              key=keyboard;
1502   4              if(key!=ksp[dis[0]]) return(key);
1503   4            }
1504   3          }
1505   2        }while(1);
1506   1      } 
1507           
1508          
1509          /*读键盘数据*/
1510          uchar  gotkey()
1511          {
1512   1        uchar  save,n;
1513   1        keyboard=0xf0;
1514   1        while(keyboard!=0xf0);    // 等待键盘松开
1515   1        delay(5000);              // 消抖阵
1516   1        if(adju_si)               // 连写输入
1517   1        {
1518   2              adju_si=0;
1519   2              for(n=0;n<60;n++)
1520   2              {
1521   3                delay(2000);
1522   3                if(keyboard!=0xf0)
1523   3                { 
1524   4                  adju_si=1;          // 在更改时,在此时间内可连成多位数
1525   4                  break;
1526   4                }
1527   3          }
1528   2        }                     
1529   1        save=keypad_scan();       // 扫描键盘
1530   1        if(save==255) return 255;     // 要求输入键盘锁密码或延时时间到达
1531   1        for (n=0;n<16;n++)
1532   1        {  
1533   2              if(save==key_code[n]) 
1534   2                 return(n);
1535   2        }
1536   1        return(20);
1537   1      }
1538          
1539          
1540          
1541          /*=====================================================================================
1542           函数名称：导航
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 26  

1543           功能描述：主菜单 工具导航  保存提示
1544           全局变量：无
1545           参数说明：
1546           返回说明：无
1547           设 计 人：LIJH
1548           版    本：1.0
1549           说    明：
1550           ======================================================================================*/
1551          
1552          
1553          /*按键按下显示 参数格式：k 按钮的显示地址*/
1554          void key_dis(uchar k)
1555          {
1556   1        display_cnasc(k,1,"\x04 ");
1557   1        delay(10000);
1558   1        if(k==0x92||k==0x96) display_cnasc(k,1,"\x1e ");
1559   1        else display_cnasc(k,1,"\x1f ");
1560   1      }
1561          
1562          
1563          
1564          /*确定按键按下显示*/
1565          void enter_dis(void)
1566          {
1567   1        display_cnasc(0x8f,1," \x09");
1568   1        delay(15000);
1569   1      }
1570          
1571          
1572          
1573          /*主菜单导航*/
1574          uchar dis_menu(void)
1575          {
1576   1        uchar d,save,key;
1577   1        if(meu)
1578   1        {  
1579   2          display_cnasc(0x81,2,"菜单");
1580   2              dis_title();
1581   2              display_cnasc(0x88,8,selected[0]);
1582   2              con_disp(0xff,0xff,0x8a,0x80,5,16);
1583   2        } 
1584   1        else    // 显示图片菜单
1585   1        {
1586   2          dis_title_pic();
1587   2              for(d=0;d<6;d++)  
1588   2            anti_nor_pic(0,d);
1589   2              anti_nor_pic(1,0);
1590   2        }      
1591   1        save=d=0;
1592   1        do
1593   1        {
1594   2              if(meu)   // 操作指示更新
1595   2              {         
1596   3                display_cnasc(0x93,3,menu_cn_2[index_m[save].left_num]);
1597   3                display_cnasc(0x8b,3,menu_cn_2[save]);
1598   3                display_cnasc(0x9b,3,menu_cn_2[index_m[save].right_num]); 
1599   3          }
1600   2              else
1601   2              {
1602   3                anti_nor_pic(0,d);     
1603   3                anti_nor_pic(1,save);
1604   3              }
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 27  

1605   2              d=save;                       // 保存上一索引
1606   2              while(1)
1607   2              {
1608   3                key=gotkey();
1609   3                if(key==11||(key==3&&meu))
1610   3                { 
1611   4                  if(meu) enter_dis();
1612   4                      break;
1613   4                }
1614   3                else if(meu)
1615   3                { 
1616   4                  if(key==2)
1617   4                      {
1618   5                        save=index_m[d].right_num;
1619   5                        key_dis(0x9a);
1620   5                        break;
1621   5                      }
1622   4                  if(key==5)
1623   4                      {
1624   5                        save=index_m[d].left_num;
1625   5                        key_dis(0x92);
1626   5                        break;
1627   5                      }
1628   4                      if((key==1&&meu))
1629   4                  {
1630   5                    d=5;
1631   5                        break;
1632   5                  } 
1633   4                }
1634   3                else 
1635   3                {
1636   4                  if(key==3){save=index_m[d].right_num; break;} // 根据导航键寻找索引
1637   4                  if(key==1){save=index_m[d].left_num; break;}
1638   4                      if(key==2||key==5){save=index_m[d].shaft_num; break;}  
1639   4            }
1640   3              }
1641   2              if(key==11||((key==1|key==3)&&meu)) break;
1642   2        }while(1);
1643   1        return d;
1644   1      }
1645          
1646          
1647          
1648          /*工具导航*/
1649          uchar tool_func(void)
1650          {
1651   1        uchar save,d,key;
1652   1        display_cnasc(0x81,2,"工具");
1653   1        dis_title();
1654   1        display_cnasc(0x88,8,selected[0]);
1655   1        con_disp(0xff,0xff,0x8a,0x80,5,16); 
1656   1        d=0;
1657   1        save=0;
1658   1        do
1659   1        {       
1660   2              display_cnasc(0x93,3,tool_menu[index_t[save].lnum]);
1661   2              display_cnasc(0x8b,3,tool_menu[save]);
1662   2              display_cnasc(0x9b,3,tool_menu[index_t[save].rnum]); 
1663   2              d=save;
1664   2              while(1)
1665   2              {
1666   3                key=gotkey();
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 28  

1667   3                if(key==1){ d=4;break;}                               // 根据按键寻找索引
1668   3                if(key==11||key==3){enter_dis();break;}
1669   3                if(key==2){save=index_t[d].rnum; key_dis(0x9a);break;}
1670   3                if(key==5){save=index_t[d].lnum; key_dis(0x92);break;}
1671   3          }
1672   2              if(key==11||key==3||key==1) break;
1673   2        }while(1);
1674   1        return d;
1675   1      }
1676          
1677          
1678          
1679          
1680          /*更改后提示保存*/
1681          void save_y_or_n(void)
1682          {
1683   1        uchar key;
1684   1        clear_dis();
1685   1        oth_run=0;      
1686   1        display_cnasc(0x92,5,"是否保存? ");
1687   1        display_cnasc(0x89,6,"Y(OK)\\N(./S)");
1688   1        while(1)
1689   1        {
1690   2              key=gotkey();
1691   2              if(key==11) 
1692   2              {
1693   3                display_cnasc(0x9a,5,"保存成功！ ");
1694   3                delay(50000);
1695   3                oth_run=1;     // 要求保存时oth_run标记为1
1696   3                return;
1697   3              }
1698   2              if(key==10) return;
1699   2        }
1700   1      } 
1701          
1702          
1703          /*=====================================================================================
1704           函数名称：调整功能
1705           功能描述：时间日期调整
1706           全局变量：today  now
1707           参数说明：见函数
1708           返回说明：无
1709           设 计 人：LIJH
1710           版    本：1.0
1711           说    明：
1712           ======================================================================================*/
1713          
1714          
1715          /*调整功能显示时间*/
1716          void asjust_time()
1717          { 
1718   1        uchar save[2];
1719   1        display_cnasc(0x8a,1,"时");
1720   1        display_cnasc(0x8c,1,"分");
1721   1        display_cnasc(0x8e,1,"秒");
1722   1        save[0]=char_num[now.hour>>4];
1723   1        save[1]=char_num[now.hour&0x0f];
1724   1        display_cnasc(0x89,1,save);
1725   1        save[0]=char_num[now.minute>>4];
1726   1        save[1]=char_num[now.minute&0x0f];
1727   1        display_cnasc(0x8b,1,save);
1728   1        save[0]=char_num[now.second>>4];
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 29  

1729   1        save[1]=char_num[now.second&0x0f];
1730   1        display_cnasc(0x8d,1,save);
1731   1      }
1732          
1733          
1734          /*调整功能月天数比较*/
1735          uchar monthday(uchar year,uchar month)
1736          {
1737   1        if(month==2&&year%4==0)
1738   1          return(29);
1739   1        else
1740   1        {     year=month&0x0f;
1741   2          month>>=4;
1742   2              month=month*10+year;    
1743   2          return(dayofmonth[month-1]);}
1744   1      }
1745          
1746          
1747          
1748          /*星期推算*/
1749          void weeks_day()
1750          { 
1751   1        uchar d,buffer,day=4; 
1752   1        if(today.month>1)
1753   1        {
1754   2          buffer=(today.month>>4);   // 将BCD码转为十进制
1755   2              buffer=buffer*10;
1756   2              buffer+=(today.month&0x0f);
1757   2              for(d=0;d<buffer-1;d++)
1758   2              {
1759   3                today.week=(dayofmonth[d]>>4);
1760   3                today.week=today.week*10;
1761   3                today.week+=(dayofmonth[d]&0x0f);
1762   3            day+=(today.week%7);
1763   3              }
1764   2        }
1765   1        buffer=(today.year>>4);
1766   1        buffer*=10;
1767   1        buffer+=(today.year&0x0f);
1768   1        if(today.year!=0)
1769   1        {
1770   2              day+=((buffer-1)/4)+buffer+1;
1771   2        }
1772   1        if(buffer%4==0&&today.month>2) day++;
1773   1        buffer=today.day>>4;
1774   1        buffer*=10;
1775   1        buffer+=(today.day&0x0f);
1776   1        today.week=(day+buffer)%7;
1777   1      }
1778          
1779          
1780          
1781          /*调整功能*/
1782          void adjust_func(void)
1783          {
1784   1        uchar d,save,b=0;
1785   1        dis_title_e();
1786   1        display_cnasc(0x82,3,menu_cn_2[0]);
1787   1        rds1302_date();
1788   1        rds1302_time();
1789   1        dis_date_mode2(0x90);
1790   1        display_cnasc(0x9a,1,"  "); 
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 30  

1791   1        asjust_time();
1792   1        display_cnasc(0x9f,1,"→");
1793   1        display_cnasc(0x90,1,"『");
1794   1        display_cnasc(0x8f,1,"』");
1795   1        d=0;save=0;
1796   1        adju_si=0;
1797   1        do
1798   1        {
1799   2          con_disp(0x00,0x00,index_a[d].lnum,index_a[d].rnum,1,13);
1800   2          con_disp(0xff,0xff,index_a[save].lnum,index_a[save].rnum,1,13);
1801   2              d=save;
1802   2              while(1)
1803   2              {
1804   3                save=gotkey();
1805   3                if(save>=0&&save<10)
1806   3                {
1807   4                  switch(d)
1808   4                  {
1809   5                    case 0: if(adju_si) // adju_si==1时两次输入连成一个数
1810   5                                { 
1811   6                                          today.year<<=4;
1812   6                                      today.year+=save;adju_si=0;
1813   6                                        } 
1814   5                            else 
1815   5                                    {
1816   6                                      today.year=save;adju_si=1;
1817   6                                    }
1818   5                                break;
1819   5                        case 1: if(adju_si)
1820   5                                {
1821   6                                          today.month<<=4;today.month+=save;
1822   6                                  if(today.month>0x12) today.month=save;
1823   6                          else adju_si=0;
1824   6                                        }
1825   5                                        else  
1826   5                                        {
1827   6                                          today.month=save;adju_si=1;
1828   6                                        }
1829   5                                        break;
1830   5                        case 2: if(adju_si)
1831   5                                {
1832   6                                          today.day<<=4;today.day+=save;  // 月天数比较
1833   6                                              if(today.year%4==0&&today.month==2&&today.day==29) ;
1834   6                                  else if(today.day>monthday(today.year,today.month)) 
1835   6                                                today.day=save;
1836   6                                              else adju_si=0;
1837   6                                        }
1838   5                                        else  {today.day=save;adju_si=1;}
1839   5                                        break;
1840   5                        case 3: if(adju_si)
1841   5                                {
1842   6                                          now.hour<<=4;now.hour+=save;
1843   6                                              if(now.hour>0x23) now.hour=save;
1844   6                                              else adju_si=0;
1845   6                                        }
1846   5                                        else  {now.hour=save;adju_si=1;}
1847   5                                        break;
1848   5                        case 4: if(adju_si)
1849   5                                {
1850   6                                          now.minute<<=4;now.minute+=save;
1851   6                                              if(now.minute>0x59) now.minute=save;
1852   6                                              else adju_si=0;
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 31  

1853   6                                        }
1854   5                                        else  {now.minute=save;adju_si=1;}
1855   5                                        break;
1856   5                        case 5: if(adju_si)
1857   5                                {
1858   6                                          now.second<<=4;now.second+=save;
1859   6                                              if(now.second>0x59) now.second=save;
1860   6                                              else adju_si=0;
1861   6                                        }
1862   5                                        else  {now.second=save;adju_si=1;}
1863   5                                        break;
1864   5                      }
1865   4                      if(today.day>monthday(today.year,today.month)) today.day=1;     // 更改月份时判断天数
1866   4                      if(today.month==0) today.month=1;
1867   4                      if(today.day==0) today.day=1;
1868   4                      if(d<3) dis_date_mode2(0x90);   // 更新显示
1869   4              else asjust_time();
1870   4                      display_cnasc(0x9a,1,"  ");             // 消去星期显示
1871   4            }
1872   3                if(save==11){save=d+1;adju_si=0;break;}
1873   3                if(save==10&&d!=0){save=d-1;adju_si=0;break;}
1874   3              }
1875   2          if(save==7&d==6) break;
1876   2        }while(1);
1877   1        weeks_day();    // 计算星期
1878   1        save_y_or_n();  // 需要保存时oth_run设为1
1879   1        if(oth_run) wds1302_time_date();
1880   1      }
1881          
1882          
1883          
1884          
1885          /*=====================================================================================
1886           函数名称：计算器功能
1887           功能描述：10位带符号数的加减乘除运算
1888           全局变量：opera  resu  i  j
1889           参数说明：见函数
1890           返回说明：无
1891           设 计 人：LIJH
1892           版    本：1.0
1893           说    明：
1894           ======================================================================================*/
1895          
1896          
1897          
1898          /*清寄存器  参数格式：m=2时结果寄存器，当m=1时操作数1，当m=0时操作数0(1),
1899                                  n=1时,只清寄存器不清显示, 0两清*/
1900          void removal_data(uchar m,uchar n)
1901          {
1902   1        uchar l;              // 当n=1时,只清寄存器不清显示, 0两清
1903   1        if(m==2)              // 当m=2时结果寄存器
1904   1        {                         // 当m=1时操作数1
1905   2          if(n==0)    // 当m=0时操作数0 ,1
1906   2                for(l=0;l<6;l++)
1907   2                  display_cnasc(0x98+l,1,"  ");
1908   2          for(l=0;l<12;l++)
1909   2            resu[l]=0;
1910   2        }
1911   1        while(m<2)
1912   1        { 
1913   2          if(n==0)
1914   2              {
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 32  

1915   3                if(m==0) 
1916   3                {  
1917   4                  for(l=0;l<6;l++)
1918   4                    display_cnasc(0x90+l,1,"  ");
1919   4                        display_cnasc(0x95,1," 0");
1920   4                }     
1921   3                else
1922   3                   for(l=0;l<6;l++)
1923   3                      display_cnasc(0x88+l,1,"  ");
1924   3              }
1925   2          for(l=0;l<12;l++)
1926   2            opera[m][l]=0;
1927   2              m++;
1928   2        }
1929   1      }
1930          
1931          
1932          
1933          
1934          /*显示数值  参数格式：显示首地址*/
1935          void dis_cdata(uchar ass)
1936          {
1937   1        uchar p,d,save[2];
1938   1        if(i==0&&opera[0][0]==1)              // 显示符号
1939   1        {
1940   2          if(cal_run)  display_cnasc(0x98,1,"=-");
1941   2          else  display_cnasc(0x90,1," -");
1942   2        }
1943   1        d=opera[i][11];                               // 计算位数
1944   1        if(opera[i][10]!=0&&opera[i][10]!=opera[i][11]+1) d++;
1945   1        save[0]=d/2;ass=ass-save[0]+5;        // 计算显示的开始位置
1946   1        p=1;
1947   1        cal_del=0;                                    // 显示点标记 （0为没有显示）
1948   1        if(d%2==1)                                    // 对位数位奇数先处理首位
1949   1        { 
1950   2          save[0]=' ';
1951   2          save[1]=char_num[opera[i][1]];
1952   2              display_cnasc(ass,1,save);
1953   2              p++;
1954   2        }
1955   1        ass++;                                                // 显示地址加一
1956   1        while(p<=opera[i][11])
1957   1        {                                                                     
1958   2          if(opera[i][10]==p&&(!cal_del)) {   // 显示点且作标记
1959   3                save[0]='.';cal_del=1;}
1960   2          else { 
1961   3                save[0]=char_num[opera[i][p]]; p++;}
1962   2          if(opera[i][10]==p&&(!cal_del)) { 
1963   3                save[1]='.';cal_del=1;}
1964   2          else{ 
1965   3                save[1]=char_num[opera[i][p]];p++;}
1966   2          display_cnasc(ass,1,save);
1967   2          ass++;
1968   2        }
1969   1      }   
1970          
1971          
1972          /*从键盘中写入数据*/   
1973          char input_data()
1974          {
1975   1        uchar save=20,c;
1976   1        for(;i<2;i++)
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 33  

1977   1        {
1978   2          while(1)
1979   2          {
1980   3      pp:   save=gotkey();    // 读键盘
1981   3                if(save==20) continue;
1982   3                if(save==11)          // 按键为确定时,选择计算或删除
1983   3                {
1984   4                  c=save=0;
1985   4                      while(1)                // 反色选择
1986   4                  { 
1987   5                        con_disp (0x00,0x00,index_cal[save].lnum,index_cal[save].rnum,2,16);
1988   5                        con_disp (0xff,0xff,index_cal[c].lnum,index_cal[c].rnum,2,16);        
1989   5                        save=gotkey();
1990   5                        if(save==10)
1991   5                        { 
1992   6                          save=c;
1993   6                              if(++c==3) c=0;
1994   6                        }
1995   5                        else if(save==11) 
1996   5                        { 
1997   6                  if(c==0) save=11;
1998   6                          else if(c==1) save=16;
1999   6                              else  return 0;
2000   6                          break;
2001   6                        }
2002   5                        else break;
2003   5              }
2004   4                      con_disp (0x00,0x00,index_cal[c].lnum,index_cal[c].rnum,2,16);      
2005   4                }
2006   3            if(save>=0&&save<=9&&j<10) 
2007   3                {
2008   4                  if(i==1&&opera[1][0]==15&&j>8) goto pp;
2009   4              if(j==2&&opera[i][1]==0&&opera[i][10]==0)
2010   4                opera[i][1]=save;             // 防止小数位不在时首位为零
2011   4                  else{
2012   5                        opera[i][j]=save;opera[i][11]=j;j++;}
2013   4                      if(i==0)                                // 显示
2014   4                        dis_cdata(0x90);
2015   4                      else
2016   4                        dis_cdata(0x88);
2017   4                }
2018   3            else if(save==10&&j<10)   
2019   3            {
2020   4                  if(opera[i][10]==0)         // 小数点空时保存
2021   4                  {
2022   5                        if(opera[i][11]==0) {opera[i][10]=2;j++;}
2023   5                    else  opera[i][10]=j;
2024   5                  }
2025   4                }
2026   3                else if(save==16)     
2027   3                {                           // 删除数据
2028   4              removal_data(i,0);j=1;
2029   4                      if(i!=0){i--;j=10;}
2030   4            }
2031   3                else if(i==1&&opera[1][11]!=0&&save>11&&save<16)
2032   3            { save1=save;break; }             // 连续计算时保存运算符
2033   3            else if(save==11&&opera[1][11]==0) continue;// 操作数1为0时不理会
2034   3                else if(save==11&&opera[1][11]!=0)  break; 
2035   3                else if((i==0||i==1&&j==1)&&save>11&&save<16){i=0; break;}    
2036   3             // 当操作数0由运算符结束输入,再按符号键更改
2037   3                else continue;
2038   3          }
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 34  

2039   2          if(opera[i][10]>opera[i][11]||opera[i][10]==0)
2040   2            opera[i][10]=opera[i][11]+1;      // 整数时小数位保存到最后
2041   2          while(opera[i][11]>=opera[i][10]&&opera[i][opera[i][11]]==0)
2042   2            opera[i][11]--;                           // 去除小数点后多余的0
2043   2          if(i==0)
2044   2          {
2045   3            opera[1][0]=save;                 // 保存运算符并显示
2046   3            display_cnasc(0x88,1,tool_cal[save-12]);
2047   3          }
2048   2          if(opera[0][11]==0) display_cnasc(0x95,1," 0");
2049   2          j=1;
2050   2          while(j<=opera[i][11]&&opera[i][j]==0) j++;//判断是否操作数是否全为0
2051   2          j--;
2052   2          if(j==opera[i][11]) opera[i][11]=0;
2053   2          j=1;
2054   2        }
2055   1        return 1;
2056   1      }
2057          
2058          
2059          /****************************************************************************************
2060          功能:  乘法运算
2061          描述:  结果由右到左保存
2062          参数:  i , j , opera[i][j],p,q,r,k,save1
2063          返回值：1(成功),0(结果位0),-1(溢出)
2064          /****************************************************************************************/
2065          
2066          char multiplication()
2067          {
2068   1        uchar p,q,r,k,save1=0; // p指向操作数0 ,q指向操作数1,r指向结果
2069   1        if(opera[0][11]==0||opera[1][11]==0) return 0;
2070   1        resu[10]=opera[0][11]+opera[1][11]-opera[0][10]-opera[1][10]+2; // RESU记录小数点后的位数
2071   1        q=opera[1][11];                                       // 记录操1的位数
2072   1        r=9;
2073   1        opera[1][11]=1;
2074   1        k=1;
2075   1        while(opera[1][k]==0) {opera[1][11]=opera[1][11]+1;k++;}      // 去除前端的0
2076   1        k=1;
2077   1        while(opera[0][k]==0) k++;                    // 去除前端的0
2078   1        resu[11]=9;
2079   1        for(resu[0]=9;q>=opera[1][11];q--,resu[0]--)
2080   1        {
2081   2          if(opera[1][q]==0) continue;                // 操1此位数为0时直接比较
2082   2          for(p=opera[0][11],r=resu[0];p>=k;p--)
2083   2          {
2084   3            save1=opera[0][p]*opera[1][q];            // 将相乘后的数保存
2085   3            resu[r]+=(save1%10);//将缓存中的数取余后加到结果中R指向的位
2086   3            save1/=10;
2087   3            save1=save1+(resu[r]/10);                 // 保存进位的数
2088   3            resu[r]%=10;                                      // 重新写入
2089   3                if(r==1)      //结果有溢出时移位
2090   3                {
2091   4                  if(save1==0&&p==k) break;   // 计算到最后位且没进位跳出
2092   4                  else if(resu[10]>0)         // 要求有小数存在
2093   4              { 
2094   5                    for(r=9;r>1;r--) resu[r]=resu[r-1]; 
2095   5                    r=1;
2096   5                resu[r]=save1;
2097   5                    resu[11]=1;
2098   5                    resu[10]--;
2099   5                    resu[0]++;
2100   5              }   
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 35  

2101   4                  else   return -1;                   // 否则溢出
2102   4                }
2103   3                if(r>1&&(r-1)<resu[11])                       // 保存结果位的最高位
2104   3                {
2105   4                  if(save1!=0) resu[11]=r-1;
2106   4                  else resu[11]=r;
2107   4                }
2108   3                if(r>1){ r--;resu[r]+=save1;}// 当R为1时只需要移位记录结果
2109   3          }
2110   2        }
2111   1        while(resu[resu[11]]==0) resu[11]++;  // 去除前端的0
2112   1        resu[0]=opera[0][0];                          // 保存符号位
2113   1        removal_data(0,1);                                    // 清数据不清显示
2114   1        if(resu[10]>8)   //如果小数点后的数有9 位或以上时，需后移到使小数点放到2的位置  
2115   1        {
2116   2          save1=resu[10]-10+resu[11];                 // 记录后移位数
2117   2          if(save1>7)  return 0;       //当后移的数大于有效数字的位数时结果为0 
2118   2          else        // 否则按需移位
2119   2          {
2120   3            for(p=save1+2,r=resu[11];p<10;p++,r++) opera[0][p]=resu[r];
2121   3                opera[0][10]=2;opera[0][11]=9;opera[0][0]=resu[0];
2122   3          }           // 因有效数小于小数点后的数,所以首位为0  
2123   2        }     
2124   1        else          //如果小数点后的数在8位以内时分两种情况
2125   1        {     
2126   2          opera[0][0]=resu[0];  
2127   2          save1=10-resu[11];  // 记录有效位数
2128   2          if(resu[10]>=save1)         // 小数的在有效数字的左边
2129   2          {   
2130   3                for(p=resu[10]+1,r=9;r>=resu[11];p--,r--)
2131   3              opera[0][p]=resu[r];    // 从小数点的最后一位开始
2132   3            opera[0][10]=2;opera[0][11]=resu[10]+1;
2133   3          }
2134   2          else                                // 小数点在有效数字内
2135   2          {  
2136   3                for(p=1,r=resu[11];r<10;p++,r++) opera[0][p]=resu[r];
2137   3                  opera[0][11]=10-resu[11];
2138   3                if(resu[10]==0) opera[0][10]=opera[0][11]+1;
2139   3                else opera[0][10]=opera[0][11]-resu[10]+1;
2140   3          }
2141   2        }
2142   1        while(opera[0][11]>=opera[0][10]&&opera[0][opera[0][11]]==0) 
2143   1          opera[0][11]--;     // 去除小数点后多余的0
2144   1        return 1;
2145   1      }
2146          
2147          
2148          /****************************************************************************************
2149          功能:  除法运算
2150          描述:  结果由左到右保存
2151          参数:  i , j , opera[i][j]
2152          p,q,r, remainde, divisor, decimal
2153          返回值：1(成功),0(结果位0),-1(溢出)
2154          *****************************************************************************************/
2155          
2156          char divider()
2157          {
2158   1        unsigned long int divisor=0,remainder=0;
2159   1        uchar p,q,r;
2160   1        char decimal=0;
2161   1        if(opera[1][11]==0) return -1;
2162   1        if(opera[0][11]==0) return 0;
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 36  

2163   1        for(r=1;r<12;r++)             // 判断两数是否相等
2164   1        {
2165   2          if(opera[0][r]!=opera[1][r]) break;
2166   2        }
2167   1        if(r==12)
2168   1        { 
2169   2          p=opera[0][0];
2170   2          removal_data(0,1);
2171   2          opera[0][0]=r;
2172   2          opera[0][1]=1;
2173   2          opera[0][10]=2;
2174   2          opera[0][11]=1;
2175   2          return 1;
2176   2        }  
2177   1        decimal=(opera[0][11]-opera[0][10])-(opera[1][11]-opera[1][10]);
2178   1        // 记录两操作数小数点后位数的差 
2179   1        if(decimal>0)         // 若操0大于操1时重新记录小数点的位置
2180   1        {
2181   2          opera[0][10]=opera[0][11]-decimal+1;
2182   2          resu[10]=opera[0][10];
2183   2        }
2184   1        else          // 否则小数点后没有数，记录有效数的位数
2185   1        {     
2186   2          opera[0][11]-=decimal;
2187   2          opera[0][10]=opera[0][11]+1;
2188   2          resu[10]=opera[0][10];
2189   2        }
2190   1        q=1;
2191   1        divisor=0;
2192   1        while(q<=opera[1][11]) // 将操1的数整形化
2193   1        {
2194   2          divisor=divisor*10+opera[1][q];q++;
2195   2        }
2196   1        if(divisor==1)   
2197   1        {
2198   2          if(resu[10]>10)     return -1;
2199   2              else return 1;
2200   2        }
2201   1        r=1;p=1;
2202   1        remainder=(unsigned long int)opera[0][1]; // 先对余数寄存器附初值
2203   1        do
2204   1        {   
2205   2              if(r>9)  // 结果位已经到达最后1位
2206   2              {  
2207   3                if(resu[1]==0&&resu[10]!=2) // 判断是否有得移位
2208   3                {     
2209   4                  for(r=1;r<9;r++) resu[r]=resu[r+1]; 
2210   4                  resu[9]=0;
2211   4                  if(resu[10]!=0) resu[10]--;
2212   4                  r=9;
2213   4                }
2214   3            else if(p>=opera[0][11]||p>=opera[0][10])  break; // 如果计算到最后一位，或者有小数点存在时结束
2215   3            else return -1; // 否则错误
2216   3              }
2217   2              resu[r]=(uchar)(remainder/divisor);     // 保存结果
2218   2          remainder=(remainder%divisor);              // 重新写入余数
2219   2              p++;r++;         
2220   2          if(p>opera[0][11]&&remainder==0) break; // 除尽后跳出
2221   2          else if(p<=opera[0][11]&&p<10)              // 余数*10后加后一位
2222   2            {remainder=remainder*10+opera[0][p];}
2223   2          else   remainder=remainder*10;       //超出后余数*10
2224   2        }while(1);
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 37  

2225   1        resu[11]=r-1;
2226   1        resu[0]=opera[0][0];
2227   1        removal_data(0,1);
2228   1        r=1;   
2229   1        while(resu[r]==0&&resu[10]!=(r+1)&&r<resu[11]) r++; 
2230   1      //去除结果前端的0
2231   1        if(r==resu[11]) return 0;
2232   1        resu[10]=resu[10]-r+1;
2233   1        p=1;
2234   1        while(r<=resu[11]){opera[0][p]=resu[r];r++;p++;}
2235   1        opera[0][0]=resu[0];opera[0][10]=resu[10];opera[0][11]=p-1;
2236   1        while(opera[0][11]>=opera[0][10]&&opera[0][opera[0][11]]==0) 
2237   1          opera[0][11]--;
2238   1        return 1;
2239   1      }
2240          
2241          
2242          /****************************************************************************************
2243          功能:  加法运算
2244          描述:  以小数点位中心两边相加
2245          参数:  i , j , opera[i][j],p,q,r
2246          返回值：1(成功),0(结果位0),-1(溢出)
2247          /****************************************************************************************/
2248          
2249          char adder()
2250          {
2251   1        uchar p,q,r;
2252   1        if(opera[0][11]==0&&opera[1][11]==0)   return 0;
2253   1        else if(opera[0][11]==0)
2254   1          {for(q=0;q<12;q++) opera[0][q]=opera[1][q];return 1;}
2255   1        else if(opera[1][11]==0) return 1; 
2256   1        else
2257   1        {
2258   2          p=opera[0][10]-1;
2259   2          q=opera[1][10]-1;
2260   2          p>q?(r=p):(r=q);
2261   2          resu[10]=r+1;               // 小数点位保存
2262   2          resu[0]=opera[0][0];        // 保存符号位
2263   2          while(r>0)                  // 将小数点前的数相应相加后放到结果中
2264   2          {
2265   3            if(p>0&&q>0){resu[r]=opera[0][p]+opera[1][q];p--;q--;}
2266   3            else if(p>0&&q==0){resu[r]=opera[0][p];p--;}
2267   3            else      {resu[r]=opera[1][q];q--;}
2268   3            r--;
2269   3          }
2270   2          r=resu[10];
2271   2          p=opera[0][10];
2272   2          q=opera[1][10];
2273   2          while(r<10)                 // 将小数点后的数放到结果中
2274   2          {
2275   3            if(p>opera[0][11]&&q>opera[1][11]) break;
2276   3            else if(p<=opera[0][11]&&q<=opera[1][11])
2277   3              {resu[r]=opera[0][p]+opera[1][q];p++;q++;}
2278   3            else if(p<=opera[0][11]&&q>opera[1][11])
2279   3              {resu[r]=opera[0][p];p++;}
2280   3            else      {resu[r]=opera[1][q];q++;}
2281   3            r++;
2282   3          }
2283   2          r--;
2284   2          resu[11]=r;
2285   2          p=0;
2286   2          while(r>0)                  // 由右到左将大于9的数进位
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 38  

2287   2          {
2288   3            resu[r]+=p;                       // p为进位标记
2289   3            p=0;
2290   3            if(resu[r]>9) {resu[r]-=10;p=1;}
2291   3            r--;
2292   3          }
2293   2          if(p==1)                            // 溢出移位
2294   2          {
2295   3            if(resu[10]==10) return -1;
2296   3            else {
2297   4              for(r=9;r>1;r--) resu[r]=resu[r-1];
2298   4              resu[1]=1;resu[10]++;}
2299   3          }
2300   2         removal_data(0,1);
2301   2         r=0; 
2302   2         while(r<12){opera[0][r]=resu[r];r++;}
2303   2         while(opera[0][11]>=opera[0][10]&&opera[0][opera[0][11]]==0)
2304   2           opera[0][11]--;
2305   2         return 1;
2306   2        }
2307   1      }
2308          
2309          /****************************************************************************************
2310           功能:  减法运算
2311           描述:  先比较两操作数的大小用one ,two互换
2312          参数:  i , j , opera[i][j],p,q,r，one，two
2313          返回值：1(成功),0(结果位0),-1(溢出)
2314          /****************************************************************************************/
2315          
2316          char subtraction()
2317          {
2318   1        uchar p,q,r,one,two;
2319   1        if(opera[0][11]==0&&opera[1][11]==0)   return 0;
2320   1        else if(opera[0][11]==0)
2321   1        {
2322   2          for(q=1;q<12;q++) 
2323   2          opera[0][q]=opera[1][q];
2324   2              opera[0][0]=!opera[0][0];return 1;
2325   2        }
2326   1        else if(opera[1][11]==0) return 1; 
2327   1        else
2328   1        { // 比较大小(大放到one)
2329   2          if(opera[0][10]>opera[1][10]){one=0;two=1;}
2330   2          else if(opera[1][10]>opera[0][10]) {one=1;two=0;}
2331   2          else
2332   2          {
2333   3            r=1;
2334   3                while(r<10&&opera[0][r]==opera[1][r]) r++;
2335   3                if(r==10) {removal_data(0,1);return 0;}
2336   3            opera[0][r]>opera[1][r]?(one=0,two=1):(one=1,two=0);
2337   3          }
2338   2          p=opera[one][10]-1;
2339   2          q=opera[two][10]-1;
2340   2          r=p;                        // 保存小数点前的数
2341   2          resu[10]=r+1;       // 保存小数点位
2342   2          resu[0]=0;          // 用作借位标记
2343   2          while(r>0)          // 小数点前相减
2344   2          {
2345   3            if(p>0&&q>0)
2346   3                {
2347   4                  opera[two][q]+=resu[0];
2348   4              resu[0]=0;
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 39  

2349   4              if(opera[one][p]>=opera[two][q])
2350   4                resu[r]=opera[one][p]-opera[two][q];
2351   4                  else
2352   4                  {
2353   5                        resu[0]=1;
2354   5                        resu[r]=10+opera[one][p]-opera[two][q];
2355   5                  }
2356   4                  p--;q--;
2357   4                }
2358   3                else 
2359   3                {         
2360   4              if(opera[one][p]<resu[0])
2361   4                {resu[r]=10+opera[one][p]-resu[0];}
2362   4                  else
2363   4                        {resu[r]=opera[one][p]-resu[0];resu[0]=0;p--;}
2364   4                }
2365   3            r--;
2366   3          }
2367   2          r=resu[10];
2368   2          p=opera[one][10];
2369   2          q=opera[two][10];
2370   2          while(r<10)         // 将小数点后的数放到结果中
2371   2          {
2372   3            if(p>opera[one][11]&&q>opera[two][11]) break;
2373   3            else if(p<=opera[one][11]&&q<=opera[two][11])
2374   3                {
2375   4              if(opera[one][p]>=opera[two][q])  resu[r]=opera[one][p]-opera[two][q];
2376   4                  else
2377   4                  {
2378   5                    resu[r]=10+opera[one][p]-opera[two][q];
2379   5                    resu[0]=r;
2380   5                    for(r-=1;r>0;r--) // 向前借位
2381   5                        {
2382   6                      if(resu[r]==0) resu[r]=9;
2383   6                          else{resu[r]-=1;break;}
2384   6                        }
2385   5                        r=resu[0];    
2386   5                  }
2387   4                  p++;q++;
2388   4                }                                         
2389   3            else if(p<=opera[one][11]&&q>opera[two][11])
2390   3              {resu[r]=opera[one][p];p++;}
2391   3            else      
2392   3                {
2393   4                  resu[r]=10-opera[two][q];  
2394   4                  resu[0]=r;
2395   4                  for(r-=1;r>0;r--)
2396   4              {
2397   5                        if(resu[r]==0) resu[r]=9;
2398   5                    else{ resu[r]-=1;break;}
2399   5                      }
2400   4                  r=resu[0];
2401   4                  q++;        
2402   4                }
2403   3            if(r==9)          // 结果溢出移位
2404   3                {
2405   4                  if(resu[1]==0&&resu[10]!=2) 
2406   4              {
2407   5                for(r=1;r<9;r++) resu[r]=resu[r+1];
2408   5                        resu[10]--;resu[9]=0;r=8;
2409   5              }
2410   4                }
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 40  

2411   3            r++;
2412   3          }
2413   2          r--;
2414   2          resu[11]=r;
2415   2          if(one==0)resu[0]=opera[0][0];      // 符号位写入
2416   2          else resu[0]=!opera[0][0];
2417   2          removal_data(0,1);
2418   2          r=1;
2419   2          while(resu[r]==0&&resu[10]!=(r+1)) r++; // 去除前端0
2420   2          resu[10]=resu[10]-r+1;                      // 重新写入小数点
2421   2          p=1;
2422   2          while(r<=resu[11]){opera[0][p]=resu[r];r++;p++;}
2423   2          opera[0][0]=resu[0];opera[0][10]=resu[10];opera[0][11]=p-1;
2424   2          while(opera[0][11]>=opera[0][10]&&opera[0][opera[0][11]]==0) opera[0][11]--;
2425   2          return 1;
2426   2        }
2427   1      }
2428          
2429          
2430          /****************************************************************************************
2431          功能:  计算器主函数
2432          描述:  根据符号位,运算符调用函数
2433          参数:  state,save
2434          返回值：无
2435          ****************************************************************************************/
2436          
2437          
2438          void calculator(void)
2439          {
2440   1        char data state;
2441   1        uchar data save;
2442   1        save1=0;
2443   1        dis_title_e();
2444   1        display_cnasc(0x82,3,tool_menu[0]); 
2445   1        display_cnasc(0x96,2,"等于");
2446   1        display_cnasc(0x8e,2,"删除");
2447   1        display_cnasc(0x9e,2,"退出");
2448   1        removal_data(2,0);    // 0为清除显示
2449   1        removal_data(0,0);
2450   1        i=0;j=1;
2451   1        while(1)
2452   1        {     
2453   2          cal_run=0;
2454   2          state=input_data();
2455   2          if(state==1)  // 根据opera[1][0]的数值调用程序
2456   2          {
2457   3            if(opera[1][0]==12&&opera[0][0]==0||opera[1][0]==13&&opera[0][0]==1) 
2458   3                  state=adder();
2459   3            else if(opera[1][0]==12&&opera[0][0]==1||opera[1][0]==13&&opera[0][0]==0)
2460   3                  state=subtraction();
2461   3            else if(opera[1][0]==14) state=multiplication();
2462   3            else state=divider();
2463   3          }
2464   2              if(state==0)  return;
2465   2          i=0;j=1;
2466   2          cal_run=1;
2467   2          switch(state)
2468   2          {
2469   3            case -1:                                          // 结果溢出
2470   3                        removal_data(2,0);
2471   3                    removal_data(0,0);  
2472   3                            display_cnasc(0x8a,3,"溢出!!");
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 41  

2473   3                            save1=0;
2474   3                                break;
2475   3            case  0:                                  // 结果为零
2476   3                                if(save1==0)
2477   3                                { 
2478   4                                  removal_data(2,1);
2479   4                                      removal_data(0,1);
2480   4                                  display_cnasc(0x98,1,"= ");
2481   4                                  display_cnasc(0x9d,1," 0");
2482   4                                }
2483   3                                break;                                // 结果显示
2484   3            case  1: 
2485   3                                if(save1==0) 
2486   3                                { 
2487   4                                  cal_run=1;
2488   4                                  display_cnasc(0x98,1,"= ");
2489   4                      dis_cdata(0x98);
2490   4                                }
2491   3                                break;
2492   3          }
2493   2              if(save1==0) save=gotkey();      // save1记录连续计算符
2494   2              cal_run=0;      
2495   2              if((save>11&&save<16&&state==1)||save1!=0) 
2496   2              {
2497   3                removal_data(2,0);
2498   3                removal_data(1,0);
2499   3                display_cnasc(0x90,6,"               ");
2500   3                if(opera[0][11]==0) display_cnasc(0x95,1," 0");
2501   3                else dis_cdata(0x90);
2502   3                if(save1!=0)save=save1;
2503   3                save1=0;
2504   3                display_cnasc(0x88,1,tool_cal[save-12]);
2505   3                opera[1][0]=save;
2506   3                i=1;j=1;
2507   3              }
2508   2              else if(save>=0&&save<10&&state==1)
2509   2              {
2510   3                removal_data(2,0);
2511   3                removal_data(0,0);
2512   3                opera[0][1]=save;
2513   3                opera[0][11]++;
2514   3                dis_cdata(0x90);
2515   3                i=0;j=2;
2516   3              }
2517   2              else if(save==10)
2518   2              {  
2519   3                removal_data(2,0);
2520   3                removal_data(0,0);
2521   3            opera[i][10]=2;
2522   3                opera[i][11]=1;
2523   3            j=2;
2524   3              }
2525   2              else 
2526   2              { 
2527   3                removal_data(2,0);
2528   3                removal_data(0,0);
2529   3              }
2530   2        }                                                                                     
2531   1      }
2532            
2533          
2534          /*=====================================================================================
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 42  

2535           函数名称：温度功能
2536           功能描述：连续检查温度
2537           全局变量：temprun  oth_run  als_temp  adju_si 
2538           参数说明：见函数
2539           返回说明：无
2540           设 计 人：LIJH
2541           版    本：1.0
2542           说    明：
2543           ======================================================================================*/
2544          
2545          
2546          /*温度显示*/
2547          uchar temp_func_dis(void)
2548          {
2549   1        uchar save[2],k;
2550   1        clear_dis();
2551   1        dis_title_e();
2552   1        display_cnasc(0x82,3,"温度计");  
2553   1        display_cnasc(0x98,3,"设定");
2554   1        display_cnasc(0x9e,3,"退出");
2555   1        display_cnasc(0x8e,1," \x1f");
2556   1        num2_asc_dis(10,0x85);
2557   1        temprun=1;
2558   1        while(1)
2559   1        {
2560   2              if(ds18b20)
2561   2          {
2562   3            if(temp.t_data[0]>99)       // 温度值大于99时
2563   3                {
2564   4                  save[0]=temp.t_data[0]/100;
2565   4              save[1]=(temp.t_data[0]/10)%10;
2566   4              num2_asc_dis(save[0],0x80);
2567   4                  num2_asc_dis(save[1],0x81);
2568   4                  save[0]=char_num[temp.t_data[0]%10];
2569   4                  num2_asc_dis(save[0],0x82);
2570   4            }
2571   3                else                                   // 温度小于100 
2572   3                {
2573   4              con_disp(0x00,0x00,0x80,0x90,1,16);
2574   4                      con_disp(0x00,0x00,0x88,0x90,1,16);
2575   4                      if(temp_pn) con_disp(0x3f,0xfc,0x80,0x9d,1,3);
2576   4                  else  con_disp(0x00,0x00,0x80,0x9d,1,3);
2577   4                  save[0]=temp.t_data[0]/10;
2578   4                  save[1]=temp.t_data[0]%10;
2579   4                  num2_asc_dis(save[0],0x81);
2580   4                  num2_asc_dis(save[1],0x82);
2581   4                }
2582   3                save[0]='.';
2583   3                save[1]=char_num[temp.t_data[1]/10];
2584   3                display_cnasc(0x8b,1,save);
2585   3                save[0]=char_num[temp.t_data[1]%10];
2586   3                if(save[0]=='1') save[1]='2';            // 补偿精度
2587   3                else if(save[0]=='7') save[1]='5';
2588   3                else if(save[0]=='8'||save[0]=='1') save[1]='7';
2589   3                else save[1]='0';
2590   3                display_cnasc(0x8c,1,save);
2591   3          }
2592   2              else 
2593   2              {
2594   3            clear_dis();
2595   3            display_cnasc(0x92,4,"没有发现");
2596   3            display_cnasc(0x8c,4,"温感器！");
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 43  

2597   3                delay_pw();
2598   3                temprun=0;
2599   3                return 0;
2600   3              }
2601   2              k=gotkey();
2602   2              if(k==2)         // 进入设置菜单
2603   2              {
2604   3                display_cnasc(0x8e,1," \x04");
2605   3                delay(35000);
2606   3                display_cnasc(0x8e,1," \x1e");
2607   3                display_cnasc(0x9a,4,"\x11 (ok) \x10");
2608   3                return 1;
2609   3              }
2610   2        }
2611   1      }
2612          
2613          /*警报温度设置*/
2614          uchar temp_func_set(void)
2615          {
2616   1        uchar save[2];
2617   1        temprun=0;
2618   1        oth_run=0;
2619   1        rds1302_data();
2620   1        while(1)
2621   1        {  
2622   2              if(oth_run)
2623   2              {
2624   3                con_disp (0x00,0x00,0x88,0x90,2,16);
2625   3                con_disp (0xff,0xff,0x8e,0x90,2,16);
2626   3              }
2627   2              else
2628   2              {
2629   3                con_disp (0xff,0xff,0x88,0x90,2,16);
2630   3                con_disp (0x00,0x00,0x8e,0x90,2,16);
2631   3              }       
2632   2              save[0]=gotkey();
2633   2              if(save[0]==1||save[0]==3) oth_run=!oth_run; 
2634   2              if(save[0]==5) return 1;
2635   2              if(save[0]==11) 
2636   2              {  
2637   3                if(oth_run) return 0;
2638   3                else  
2639   3                { 
2640   4                      clear_dis();
2641   4                      dis_title_e();
2642   4                      save[1]=save[0]=0;
2643   4                      oth_run=0;
2644   4                  dis_title_e();
2645   4              display_cnasc(0x82,3,"设  定"); 
2646   4                  display_cnasc(0x90,5,"警报温度：");
2647   4                      display_cnasc(0x88,7,"高于【    】℃"); 
2648   4                      display_cnasc(0x98,8,"低于【    】℃ \x10"); 
2649   4                      while(1)
2650   4                      {
2651   5                        if(save[1]==2) con_disp(0x00,0x00,index_temp_set[save[1]].lnum,index_temp_set[save[1]].rnum,2,13);
2652   5                        else con_disp(0x00,0x00,index_temp_set[save[1]].lnum,index_temp_set[save[1]].rnum,2,13);
2653   5                        if(save[0]==2) con_disp(0x0f,0xff,index_temp_set[save[0]].lnum,index_temp_set[save[0]].rnum,1,13);
2654   5                else con_disp(0xff,0xff,index_temp_set[save[0]].lnum,index_temp_set[save[0]].rnum,2,13);
2655   5                    save[1]=save[0];
2656   5                adju_si=0;
2657   5                        oth_run=0;
2658   5                        while(1)
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 44  

2659   5                        {
2660   6                          for(i=0;i<2;i++)
2661   6                          {
2662   7                            j=0x8b+i*16;
2663   7                                if(als_temp[i]==255) display_cnasc(j,2," off"); // 255值为关闭值
2664   7                            else 
2665   7                                {
2666   8                                  save1=save[1];
2667   8                                  if(als_temp[i]>127)  // 当数值大于127时温度值为负数
2668   8                                  { 
2669   9                                        display_cnasc(j,1,"- ");
2670   9                                        save[0]=char_num[(als_temp[i]-128)/10];
2671   9                                        save[1]=char_num[(als_temp[i]-128)%10];
2672   9                                        display_cnasc(j+1,1,save);
2673   9                                  }
2674   8                                  else
2675   8                                  {
2676   9                                        save[0]=' ';
2677   9                                        save[1]=char_num[als_temp[i]/100];
2678   9                                        if(save[1]=='0') save[1]=' ';
2679   9                                        display_cnasc(j,1,save);
2680   9                                        save[0]=char_num[als_temp[i]/10%10];
2681   9                                        save[1]=char_num[als_temp[i]%10];
2682   9                                        display_cnasc(j+1,1,save);
2683   9                                  }
2684   8                                  save[1]=save1;
2685   8                                }
2686   7                          }           
2687   6                              save[0]=gotkey();
2688   6                              do                 // 输入符号等待数值输入或下一位
2689   6                              {
2690   7                                if(save[0]==13){ oth_run=1;display_cnasc(0x8b+save[1]*16,2,"-   ");}
2691   7                                else if(save[0]==12){ oth_run=0;display_cnasc(0x8b+save[1]*16,2,"    ");}
2692   7                                else break;
2693   7                                save[0]=gotkey();
2694   7                                if(save[0]>=0&&save[0]<10||save[0]==11) break;
2695   7                              }while(1);
2696   6                              if(save[0]==14){ als_temp[save[1]]=255;}  // 乘号直接将警报温度关闭
2697   6                              if(save[0]>=0&&save[0]<10&&save[1]<2)
2698   6                          {
2699   7                                if(adju_si)
2700   7                            { 
2701   8                                  adju_si=0;
2702   8                                  if(oth_run) als_temp[save[1]]&=0x7f;  // 消去符号位
2703   8                                      if(als_temp[save[1]]>24&&!oth_run) als_temp[save[1]]=240;
2704   8                              else als_temp[save[1]]=als_temp[save[1]]*10+save[0];
2705   8                                      if(oth_run&&als_temp[save[1]]>50) als_temp[save[1]]=50;                 
2706   8                                      if(!oth_run&&als_temp[save[1]]>120) als_temp[save[1]]=120; 
2707   8                                      if(!oth_run&&als_temp[save[1]]<100) adju_si=1;  // 根据数值打开连写
2708   8                                      if(oth_run&&als_temp[save[1]]<10)  adju_si=1;
2709   8                                }
2710   7                                else
2711   7                                { 
2712   8                                  als_temp[save[1]]=save[0];
2713   8                                      adju_si=1;
2714   8                                }
2715   7                                if(oth_run) als_temp[save[1]]=als_temp[save[1]]|0x80;  // 写入符号
2716   7                                else als_temp[save[1]]=als_temp[save[1]]&0x7f;
2717   7                              }                       
2718   6                              if(save[0]==11)
2719   6                              {
2720   7                                if(als_temp[1]!=255&&als_temp[0]!=255)           // 上下限温度调整
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 45  

2721   7                                {
2722   8                              if(save[1]==0&&als_temp[0]<als_temp[1]){als_temp[0]=als_temp[1];}
2723   8                                  if(save[1]==1&&als_temp[1]>als_temp[0]){als_temp[1]=als_temp[0];}
2724   8                                }
2725   7                                save[0]=save[1]+1;adju_si=0;break;}
2726   6                      if(save[0]==10&&save[1]!=0) {save[0]=save[1]-1;adju_si=0;break;}
2727   6                        }
2728   5                        oth_run=0;
2729   5                        if(save[0]==3&&save[1]==2) break;
2730   5                      }
2731   4                      save_y_or_n();
2732   4                      if(oth_run)
2733   4                      { 
2734   5                        wds1302_data(d02_temp,als_temp[0]);
2735   5                        wds1302_data(d02_temp+2,als_temp[1]);
2736   5                      }
2737   4                      return 1;
2738   4                }
2739   3              }
2740   2        }
2741   1      }                  
2742                                            
2743                           
2744          /*温度计主函数*/                 
2745          void temp_func(void)
2746          {                
2747   1        uchar t;      
2748   1        while(1)
2749   1        {
2750   2          oth_run=1;
2751   2              t=temp_func_dis();
2752   2          if(t==1)
2753   2              {
2754   3                t=temp_func_set();
2755   3                if(t==0) return;
2756   3              }
2757   2          else return;
2758   2        }
2759   1      } 
2760          /*=====================================================================================
2761           函数名称：闹铃功能
2762           功能描述：设定闹铃
2763           全局变量：alarm_time adju_si
2764           参数说明：见函数
2765           返回说明：无
2766           设 计 人：LIJH
2767           版    本：1.0
2768           说    明：
2769           ======================================================================================*/
2770          
2771          
2772          void alarm_func(void)
2773          {
2774   1        uchar save[2],a,d;
2775   1        clear_dis();
2776   1        dis_title_e();
2777   1        display_cnasc(0x82,3,"闹  钟");  
2778   1        display_cnasc(0x91,6,"状态：\x11    \x10");
2779   1        display_cnasc(0x89,3,"闹铃："); 
2780   1        display_cnasc(0x9f,1,"→");
2781   1        display_cnasc(0x90,1,"『");
2782   1        display_cnasc(0x8f,1,"』"); 
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 46  

2783   1        adju_si=0; 
2784   1        a=0;d=0;
2785   1        save[0]=char_num[alarm_time[0]>>4];
2786   1        save[1]=char_num[alarm_time[0]&0x0f];
2787   1        display_cnasc(0x8c,1,save);
2788   1        display_cnasc(0x8d,1,": ");
2789   1        save[0]=char_num[alarm_time[1]>>4];
2790   1        save[1]=char_num[alarm_time[1]&0x0f]; 
2791   1        display_cnasc(0x8e,1,save);
2792   1        do 
2793   1        {
2794   2          if(a==0)
2795   2              {    
2796   3                display_cnasc(0x95,1,alm_sign[alm]);
2797   3            display_cnasc(0x94,1,"\x11 ");
2798   3            display_cnasc(0x96,1," \x10");
2799   3                con_disp(0x00,0x00,index_alm[d-1].lnum,index_alm[d-1].rnum,1,14);
2800   3              }
2801   2          if(a>0&&a<4)
2802   2              {
2803   3                if(d==0)
2804   3                {
2805   4                      display_cnasc(0x94,1,"  ");
2806   4              display_cnasc(0x96,1,"  ");
2807   4                }
2808   3                else 
2809   3                 con_disp(0x00,0x00,index_alm[d-1].lnum,index_alm[d-1].rnum,1,14);
2810   3               con_disp(0xff,0xff,index_alm[a-1].lnum,index_alm[a-1].rnum,1,14);      
2811   3          }             
2812   2              d=a;
2813   2              while(1)
2814   2              {
2815   3                a=gotkey();
2816   3                if((a==1||a==3)&&d==0)
2817   3                { 
2818   4                  alm=!alm;
2819   4                      if(a==1) display_cnasc(0x94,1,"\x09 ");
2820   4                      else display_cnasc(0x96,1," \x09");
2821   4                      delay(35000);
2822   4                      if(a==1) display_cnasc(0x94,1,"\x11 ");
2823   4              else display_cnasc(0x96,1," \x10");
2824   4                      display_cnasc(0x95,1,alm_sign[alm]);
2825   4                }
2826   3                if(d>0&&d<3&&a>=0&&a<10)
2827   3                {
2828   4                  if(adju_si)
2829   4                      {
2830   5                        alarm_time[d-1]<<=4;alarm_time[d-1]+=a;
2831   5                        if(d==1&&alarm_time[0]>0x23) alarm_time[0]=a;
2832   5                        else if(d==2&&alarm_time[1]>0x59) alarm_time[1]=a;
2833   5                        else adju_si=0;
2834   5                      }
2835   4                  else  
2836   4                      {
2837   5                        alarm_time[d-1]=a;adju_si=1;
2838   5                      }
2839   4                      save[0]=char_num[alarm_time[d-1]>>4];
2840   4                  save[1]=char_num[alarm_time[d-1]&0x0f];
2841   4                  display_cnasc(0x8c+(d-1)*2,1,save);
2842   4                }
2843   3                if(a==11){a=d+1;break;}
2844   3                if(a==10&&d!=0){a=d-1;break;}
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 47  

2845   3              }
2846   2              adju_si=0;
2847   2              if(a==4) 
2848   2              { 
2849   3                save_y_or_n();
2850   3                wds1302_data(d02_signs,signs);
2851   3                wds1302_data(d02_alm,alarm_time[0]);
2852   3                wds1302_data(d02_alm+2,alarm_time[1]);
2853   3                return;
2854   3              }
2855   2        }while(1);
2856   1      }
2857          
2858          
2859          
2860          /*=====================================================================================
2861           函数名称：篮球器功能
2862           功能描述：分数  时间  24秒  
2863           全局变量：resu  opera
2864           参数说明：见函数
2865           返回说明：无
2866           设 计 人：LIJH
2867           版    本：1.0
2868           说    明：
2869           ======================================================================================*/
2870          
2871          /*比赛设置*/
2872          void nba_set(void)
2873          {
2874   1        uchar nba,save1,key,save[2];
2875   1        clear_dis();
2876   1        dis_title_e(); 
2877   1        if(resu[7]==1) display_cnasc(0x82,3,"加  时");
2878   1        else  
2879   1        {
2880   2          display_cnasc(0x82,3,"设  定");
2881   2          opera[0][0]=0;
2882   2          opera[1][0]=1;
2883   2        }
2884   1        resu[6]=0;    // 赋初值
2885   1        resu[0]=1;
2886   1        resu[1]=4;
2887   1        resu[2]=12;
2888   1        resu[3]=0;
2889   1        resu[4]=24;
2890   1        display_cnasc(0x90,7,"队1:红  队2:白");
2891   1        display_cnasc(0x88,7,"24秒:Y  节数:4");
2892   1        display_cnasc(0x98,8,"每节时间: 12分钟");
2893   1        save1=0;nba=0;
2894   1        while(1)
2895   1        {
2896   2          if(save1==4) display_cnasc(0x9c,1,":");
2897   2              else display_cnasc(index_nba[save1],1,"  ");
2898   2              if(nba==4)  display_cnasc(0x9c,1,":\x10");
2899   2              else display_cnasc(index_nba[nba],1,"\x11 "); 
2900   2              save1=nba;
2901   2              key=gotkey();   
2902   2              if(key==1||key==3)
2903   2              {         
2904   3                switch(nba)     // 导航更改数据
2905   3                {
2906   4                  case 0:                         
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 48  

2907   4                      case 1:
2908   4                              if(key==1){if(opera[nba][0]>0) opera[nba][0]--;
2909   5                                                 else opera[nba][0]=7;}
2910   4                                      if(key==3){if(opera[nba][0]<7) opera[nba][0]++;
2911   5                                                 else opera[nba][0]=0;}
2912   4                                      display_cnasc(index_nba[nba]-1,1,nba_oppo[opera[nba][0]]);
2913   4                                      break;
2914   4                      case 2:
2915   4                                      if(resu[0]>0) resu[0]=0;
2916   4                                      else resu[0]=1;
2917   4                                      if(resu[0]>0)   display_cnasc(0x8a,1,":Y");
2918   4                                      else display_cnasc(0x8a,1,":N");
2919   4                                      break;
2920   4                      case 3:
2921   4                                      if(key==1){if(resu[1]>1) resu[1]--;
2922   5                                                  else  resu[1]=4;}
2923   4                                  if(key==3){if(resu[1]<4) resu[1]++;
2924   5                                             else resu[1]=1;}
2925   4                                      save[0]=':';
2926   4                                      save[1]=char_num[resu[1]];
2927   4                              display_cnasc(0x8e,1,save);
2928   4                                      break;
2929   4                      case 4:
2930   4                                      if(key==1){if(resu[2]>0) resu[2]--;
2931   5                                                  else  resu[2]=60;}
2932   4                                  if(key==3){if(resu[2]<60) resu[2]++;
2933   5                                             else resu[2]=0;}
2934   4                                      save[0]=char_num[resu[2]/10];
2935   4                                      save[1]=char_num[resu[2]%10];
2936   4                              display_cnasc(0x9d,1,save);
2937   4                                      resu[5]=resu[2];
2938   4                                      break;
2939   4            }
2940   3              }
2941   2              if(key==11) 
2942   2              {
2943   3                nba++; if(nba==5) return;                        
2944   3              }
2945   2              if(key==10&&nba!=0)  nba--;
2946   2        }
2947   1      }
2948          
2949          
2950          
2951          /*界面其他元素*/
2952          void nba_oth_dis(void)
2953          {
2954   1        uchar save[2];
2955   1        if(resu[7]==1) display_cnasc(0x80,5,"加时时间：");
2956   1        else display_cnasc(0x80,5,"比赛时间：");
2957   1        display_cnasc(0x98,1,nba_oppo[opera[0][0]]);
2958   1        display_cnasc(0x9e,1,nba_oppo[opera[1][0]]);
2959   1        display_cnasc(0x99,1,"队");
2960   1        display_cnasc(0x9f,1,"队");
2961   1        save[0]='0';
2962   1        save[1]=char_num[resu[6]+1];
2963   1        display_cnasc(0x9b,1,save);
2964   1        display_cnasc(0x9c,1,"st");
2965   1        con_disp(0xff,0xff,0x83,0x90,2,1); // 画正方框
2966   1        con_disp(0xff,0xff,0x8b,0x8f,2,1);
2967   1        con_disp(0x80,0x00,0x83,0x91,1,15);
2968   1        con_disp(0x00,0x01,0x84,0x91,1,15);
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 49  

2969   1        con_disp(0x80,0x00,0x8b,0x80,1,15);
2970   1        con_disp(0x00,0x01,0x8c,0x80,1,15);
2971   1        nba_dis_time();
2972   1        if(resu[0]==0) display_cnasc(0x93,2,"\x07--\x07");
2973   1        display_cnasc(0x8b,2," S! ");
2974   1      }
2975          
2976          
2977          
2978          /*篮球器主函数*/
2979          void nba_timer(void)
2980          {
2981   1        uchar save,key,nba=0;
2982   1        als=di0=1;alm=keb=di1=oth_run=0;
2983   1        time_init();  
2984   1        display_cnasc(0x82,3,"篮球器");
2985   1        dis_title_e(); 
2986   1        removal_data(0,1); 
2987   1        while(1)        // 使用说明
2988   1        {
2989   2              display_cnasc(0x90,8,timer_tips[nba]);
2990   2              display_cnasc(0x88,8,timer_tips[nba+1]);
2991   2              display_cnasc(0x98,8,timer_tips[nba+2]);
2992   2              key=gotkey();
2993   2              if(key==11)
2994   2              {
2995   3                nba+=3;
2996   3                if(nba>9) break;
2997   3              }
2998   2              if(key==10)
2999   2              {
3000   3                if(nba>0) nba-=3 ;
3001   3              }
3002   2        }
3003   1      nn:
3004   1        nba_set();
3005   1        clear_dis();
3006   1        nba_oth_dis();
3007   1        nba_tim=1;
3008   1        while(1)
3009   1        {     
3010   2              for(save=0x80,nba=0;nba<2;nba++)
3011   2              {
3012   3                if(opera[nba][1]>99)  // 分数显示
3013   3                {
3014   4                  num2_asc_dis(opera[nba][1]/100,save);
3015   4                      num2_asc_dis(opera[nba][1]/10%10,save+1);
3016   4                      num2_asc_dis(opera[nba][1]%10,save+2);
3017   4                }
3018   3                else
3019   3                {
3020   4                      num2_asc_dis(opera[nba][1]/10,save);
3021   4                      num2_asc_dis(opera[nba][1]%10,save+1);
3022   4            }
3023   3                if(opera[1][1]>99) save=0x85;
3024   3                else save=0x86;
3025   3              }
3026   2              
3027   2              do
3028   2              {
3029   3              key=gotkey();
3030   3        ss:
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 50  

3031   3              switch(key)
3032   3              {
3033   4                case 12:
3034   4                case 13:
3035   4                         if(key==12)
3036   4                                   {if(opera[0][1]<250) opera[0][1]++;}
3037   4                         else 
3038   4                                   {if(opera[0][1]>0) opera[0][1]--;}
3039   4                                 save=110;
3040   4                                 break;
3041   4                case 14:
3042   4                case 15:
3043   4                         if(key==14)
3044   4                                   {if(opera[1][1]<250) opera[1][1]++;}
3045   4                         else 
3046   4                                   {if(opera[1][1]>0) opera[1][1]--;}
3047   4                                 save=110;
3048   4                                 break;
3049   4                case  7:
3050   4                         TR1=TR0=EA=0;
3051   4                         if((++resu[3])>59)
3052   4                         {
3053   5                           resu[3]=0;
3054   5                               if((++resu[2])>59)
3055   5                                       { 
3056   6                                         resu[3]=0;
3057   6                                         if(++resu[2]>60) resu[2]=0;
3058   6                                       }
3059   5                                 }
3060   4                             if(resu[4]<24) resu[4]++;
3061   4                                 nba_dis_time();
3062   4                                 break;
3063   4                case  8:
3064   4                         if(resu[0]==1)
3065   4                                 { 
3066   5                                   TL1=(time_count&0x00FF);
3067   5                       TH1=(time_count>>8);
3068   5                                   resu[4]=24; nba_dis_time();
3069   5                                       TR0=TR1=EA=1;
3070   5                                 }
3071   4                                 break;
3072   4                case  9: 
3073   4                         if(resu[2]==0&&resu[3]==0)
3074   4                         {
3075   5                           resu[2]=resu[5];resu[4]=24;
3076   5                                       if(resu[6]==resu[1])
3077   5                                       {                                                        // 判断比分进行加时赛
3078   6                                         if(opera[0][1]==opera[1][1]){nba_tim=0;resu[7]=1; goto nn;}
3079   6                                         while(gotkey()!=10);           // 否则只能退出
3080   6                                         signs=r1302(d02_signs+1); 
3081   6                                         nba_tim=0;
3082   6                                         return;
3083   6                                       }
3084   5                                       else nba_oth_dis();
3085   5                                       break;
3086   5                         } 
3087   4                                 if(EA) {TR0=TR1=EA=0;break;}
3088   4                         if(!EA&resu[4]!=0){ EA=TR0=1;if(resu[0]==1) TR1=1;}
3089   4                                 break;                                                                                                                
3090   4                case 10:
3091   4                case 11:
3092   4                         if(!EA)                      // 暂停状态下 ok键两次返回时钟界面
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 51  

3093   4                                 {                //  ./s 键两次退出
3094   5                                   delay(6000);
3095   5                                       save=gotkey();
3096   5                                       if(save==key)
3097   5                                       {
3098   6                                         if(key==11)
3099   6                                         {
3100   7                                           clear_dis();oth_run=1;
3101   7                                           rds1302_time();
3102   7                                               init_d2=1;
3103   7                                           dis_mode2();
3104   7                                               init_d2=0;
3105   7                                           while(gotkey()!=11);
3106   7                                           oth_run=0;
3107   7                                               save=110;
3108   7                                           clear_dis();
3109   7                                           nba_oth_dis();
3110   7                                         }
3111   6                                         else{ signs=r1302(d02_signs+1); nba_tim=0;return;}
3112   6                                   }
3113   5                                       else{ key=save;goto ss;}
3114   5                                 }
3115   4                                 break;         
3116   4              }
3117   3              if(save==110)  break;
3118   3          }while(1);  
3119   2        }  
3120   1      }
3121          
3122                   
3123          /*=====================================================================================
3124           函数名称：设置功能
3125           功能描述：系统状态设置  
3126           全局变量：signs
3127           参数说明：见函数
3128           返回说明：无
3129           设 计 人：LIJH
3130           版    本：1.0
3131           说    明：
3132           ======================================================================================*/
3133          
3134          
3135          /*设置调整内容 参数格式：选中设置项，设置项子值*/
3136          uchar set_dis(uchar menu,uchar sub)
3137          {
3138   1        uchar save;
3139   1        con_disp(0xff,0xff,0x8e,0x80,2,16);
3140   1        con_disp(0x00,0x00,0x8a,0x80,4,16);
3141   1        display_cnasc(0x96,1,"\x1e ");
3142   1        display_cnasc(0x9e,1,"\x1f ");
3143   1        display_cnasc(0x92,1,"  ");
3144   1        display_cnasc(0x9a,1,"  ");
3145   1        display_cnasc(0x8d,1,"\x11 ");
3146   1        display_cnasc(0x8a,1,"  ");
3147   1        while(1)
3148   1        {
3149   2          
3150   2          if(menu<2)
3151   2            display_cnasc(0x8e,2,set_bl_dm[menu][sub]);
3152   2          else
3153   2                display_cnasc(0x8e,2,set_mka[menu-2][sub]);
3154   2              save=gotkey();
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 52  

3155   2              if(save==5)
3156   2              {
3157   3                key_dis(0x96);
3158   3                if(sub==0&&menu<2) sub=2;
3159   3                else if(sub==0&&menu>1) sub=1;
3160   3                else sub--;
3161   3          }
3162   2              if(save==2)
3163   2              {
3164   3                key_dis(0x9e);
3165   3                if(sub==2&&menu<2) sub=0;
3166   3                else if(sub==1&&menu>1) sub=0;
3167   3                else sub++;
3168   3              }
3169   2              if(save==1||save==11)
3170   2              {
3171   3                display_cnasc(0x8d,1,"\x04 ");
3172   3              delay(30000);
3173   3                con_disp(0x00,0x00,0x8e,0x80,2,16);
3174   3            con_disp(0xff,0xff,0x8a,0x80,4,16);
3175   3            display_cnasc(0x92,1,"\x1e ");
3176   3            display_cnasc(0x9a,1,"\x1f ");
3177   3            display_cnasc(0x96,1,"  ");
3178   3            display_cnasc(0x9e,1,"  ");
3179   3                display_cnasc(0x8a,1,"【");
3180   3                display_cnasc(0x8d,3,"】\x10 \x04 ");
3181   3                return(sub);    // 返回设置值
3182   3              }
3183   2        }
3184   1      }
3185          
3186          
3187          /*设置调整*/
3188          void set_func(void)
3189          {
3190   1        uchar d,key,save;
3191   1        display_cnasc(0x81,2,"设置");
3192   1        dis_title();
3193   1        display_cnasc(0x88,8,selected[1]);
3194   1        con_disp(0xff,0xff,0x8a,0x80,4,16);
3195   1        save=d=0;
3196   1        do
3197   1        {       
3198   2              display_cnasc(0x93,2,set_menu[index_s[save].lnum]);
3199   2              display_cnasc(0x8b,2,set_menu[save]);
3200   2              display_cnasc(0x9b,2,set_menu[index_s[save].rnum]); 
3201   2              d=save;
3202   2              while(1)
3203   2              {
3204   3                key=gotkey();
3205   3                if(key==11||key==3){ enter_dis();break;}
3206   3                if(key==5){save=index_s[d].lnum;key_dis(0x92); break;}
3207   3                if(key==2){save=index_s[d].rnum;key_dis(0x9a); break;}
3208   3                if(key==1){ wds1302_data(d02_signs,signs); return;}
3209   3          }
3210   2              if(key==11||key==3)
3211   2              {
3212   3            save=0;
3213   3            for(key=0;key<2;key++)  //  进行两次比较 首次为现时值 其次为设定置更改 
3214   3            {
3215   4              switch(d)
3216   4              {
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 53  

3217   5                case 0: 
3218   5                                if(key==1)
3219   5                                {
3220   6                                          bl0=bl1=0;
3221   6                                              if(save==1) bl0=1;
3222   6                                              if(save==2)     bl1=1;
3223   6                                }
3224   5                            else 
3225   5                                        {if(bl0) save=1; if(bl1) save=2;}
3226   5                                        if(bl1) lcd_bl=close;
3227   5                                        else lcd_bl=open;
3228   5                                    break;
3229   5                    case 1: 
3230   5                                if(key==1)
3231   5                                {
3232   6                                          di0=di1=0;
3233   6                                              if(save==1) di0=1;
3234   6                                              if(save==2)     di1=1;
3235   6                                }
3236   5                                    else {if(di0) save=1; if(di1) save=2;}
3237   5                                    break;
3238   5                    case 2: 
3239   5                                if(key==1) meu=(bit)save;
3240   5                            else {if(meu) save++;}          
3241   5                                    break;
3242   5                case 3: 
3243   5                                if(key==1) keb=(bit)save;
3244   5                            else{if(keb) save++;}           
3245   5                                    break;
3246   5                case 4: 
3247   5                                if(key==1) als=(bit)save;
3248   5                            else{if(als) save++;}           
3249   5                                    break;
3250   5                case 5: wds1302_data(d02_signs,signs);
3251   5                            return;
3252   5              }
3253   4              if(key==0) save=set_dis(d,save);
3254   4            }
3255   3                save=d;
3256   3              }
3257   2        }while(1);
3258   1      }
3259          
3260          
3261          /*=====================================================================================
3262           函数名称：保密功能
3263           功能描述：系统重设  密码锁  密码更改  
3264           全局变量：resu  
3265           参数说明：见函数
3266           返回说明：无
3267           设 计 人：LIJH
3268           版    本：1.0
3269           说    明：
3270           ======================================================================================*/
3271          
3272          
3273          /*密码整理*/
3274          void passwork_finish()
3275          {
3276   1        uchar i;
3277   1        for(i=0;i<6;i+=2)
3278   1        {
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 54  

3279   2          resu[i]<<=4;
3280   2              resu[i]+=resu[i+1];
3281   2        }
3282   1      }
3283          
3284          
3285          
3286          /*读取密码*/
3287          uchar input_passwork()
3288          {
3289   1        uchar i,save[2];
3290   1        save[0]=' ';
3291   1        display_cnasc(0x9d,3,"(./S)\x10");
3292   1        for(i=0;i<6;i++)
3293   1        {
3294   2          while(1)
3295   2              {
3296   3                resu[i]=gotkey();
3297   3                if(resu[i]>=0&&resu[i]<10) break;
3298   3                if(resu[i]==10) return 10;
3299   3              }
3300   2          save[1]=char_num[resu[i]];
3301   2              display_cnasc(0x89+i,1,save); 
3302   2              delay(20000);
3303   2              display_cnasc(0x89+i,1," *");
3304   2        }
3305   1        return 11;
3306   1      }
3307          
3308          
3309          
3310          /*密码确认*/
3311          void input_second_passwork()
3312          {
3313   1        uchar i,save[2];
3314   1        save[0]=' ';
3315   1        display_cnasc(0x89,6,"            ");
3316   1        for(i=0;i<6;i++)
3317   1        {    
3318   2              if(resu[i]!=gotkey())   break;
3319   2              save[1]=char_num[resu[i]];
3320   2              display_cnasc(0x89+i,1,save); 
3321   2              delay(20000);
3322   2              display_cnasc(0x89+i,1," *");
3323   2        }
3324   1        if(i!=6)
3325   1        {
3326   2          display_cnasc(0x89,6,"密码不相同！");
3327   2              delay(50000);
3328   2              display_cnasc(0x9a,6,"任意键 \x10    ");
3329   2              while(gotkey()==0xf0);
3330   2              return;
3331   2        }
3332   1        else
3333   1        {
3334   2              passwork_finish();
3335   2              for(i=0;i<6;i+=2)
3336   2                wds1302_data(d02_passw+i,resu[i]);
3337   2              for(i=0;i<6;i+=2)
3338   2                if(resu[i]!=r1302(d02_passw+i+1)) break;
3339   2              if(i==6)
3340   2               {display_cnasc(0x98,8,"\x10 更改成功!(OK) ");
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 55  

3341   3                while(gotkey()!=11);return;}
3342   2              else
3343   2                display_cnasc(0x9a,6,"更改失败！  ");
3344   2        }
3345   1        delay_pw();
3346   1      }                               
3347          
3348          
3349          
3350          /*密码比较*/
3351          uchar passwork_comp()
3352          {
3353   1        uchar i;
3354   1        passwork_finish();
3355   1        for(i=0;i<6;i+=2)
3356   1              if(resu[i]!=r1302(d02_passw+i+1)) break;
3357   1        if(i==6)       return 1;
3358   1        else
3359   1        { 
3360   2          display_cnasc(0x89,6,"  密码错误！");
3361   2              delay_pw();
3362   2              display_cnasc(0x89,6,"            ");
3363   2              return 110;
3364   2        }
3365   1      }
3366          
3367          
3368          
3369          /*保密导航*/
3370          void passw_func(void)
3371          {
3372   1        uchar save,d,key;
3373   1        d=0;save=0;
3374   1        do
3375   1        {
3376   2          clear_dis();
3377   2              display_cnasc(0x81,2,"保密");
3378   2          dis_title();
3379   2          display_cnasc(0x88,8,selected[0]);
3380   2          con_disp(0xff,0xff,0x8a,0x80,5,16); 
3381   2          do
3382   2          {     
3383   3                display_cnasc(0x93,3,secrets_menu[index_p[save].lnum]);
3384   3                display_cnasc(0x8b,3,secrets_menu[save]);
3385   3                display_cnasc(0x9b,3,secrets_menu[index_p[save].rnum]);  
3386   3                d=save;
3387   3                while(1)
3388   3                {
3389   4                  key=gotkey();
3390   4                  if(key==11||key==3){enter_dis();break;}
3391   4                  if(key==2){save=index_p[d].rnum; key_dis(0x9a);break;}
3392   4                  if(key==5){save=index_p[d].lnum; key_dis(0x92);break;}
3393   4                      if(key==1){return;}
3394   4            }
3395   3            if(key==11||key==3)
3396   3                {     
3397   4                      if(d==3) return;                
3398   4                      clear_dis();
3399   4                      dis_title_e();
3400   4              switch(d)
3401   4              {
3402   5                case 0: 
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 56  

3403   5                                display_cnasc(0x82,3,"密码锁");
3404   5                                        display_cnasc(0x90,5,"输入密码：");
3405   5                                        while(1)
3406   5                                        {
3407   6                                          key=input_passwork();
3408   6                                          if(key==10) break;
3409   6                                          key=passwork_comp();
3410   6                                          if(key==1) 
3411   6                                  {
3412   7                                            display_cnasc(0x90,8,"处开启状态，按键");
3413   7                                    display_cnasc(0x88,8,"□1-常开□2-关闭");
3414   7                                            display_cnasc(0x98,8,"■自动延时30秒  ");
3415   7                                                pw_oc=open;
3416   7                                            save1=i=0;   
3417   7                                            lock_op=1;   // 开启标记等待延时
3418   7                                            while(1)
3419   7                                            {
3420   8                                                  key=gotkey(); // 返回255为延时时间到达
3421   8                                                  if(key==255){ lock_op=0;pw_oc=close;break;}
3422   8                                                  if(key==1) 
3423   8                                                  {
3424   9                                                    display_cnasc(0x88,1,"■");
3425   9                                                    display_cnasc(0x98,1,"□");
3426   9                                                    lock_op=0;
3427   9                                                  }
3428   8                                                  if(key==2)
3429   8                                                  {
3430   9                                                    display_cnasc(0x88,1,"□");
3431   9                                                        display_cnasc(0x98,1,"□");
3432   9                                                        display_cnasc(0x8c,1,"■");
3433   9                                                        delay(60000);
3434   9                                                        clear_dis();
3435   9                                                    dis_title_e();
3436   9                                        display_cnasc(0x82,3,"密码锁");
3437   9                                                    display_cnasc(0x90,5,"密码锁将在");
3438   9                                                        display_cnasc(0x8a,6," 5秒后关闭：");
3439   9                                                    for(save=0;save<5;save++)
3440   9                                                    { 
3441  10                                                      display_cnasc(0x99+save,1,"→"); 
3442  10                                                          delay_pw();
3443  10                                                    }
3444   9                                                        display_cnasc(0x9e,1,"√");
3445   9                                                        pw_oc=open;
3446   9                                                        delay(30000);
3447   9                                                        pw_oc=close;
3448   9                                                    lock_op=0;
3449   9                                                    break;
3450   9                                                  }
3451   8                                            }
3452   7                                                break;
3453   7                                          }
3454   6                                        } 
3455   5                                    break;
3456   5                    case 1: 
3457   5                                display_cnasc(0x82,3,"更  改");
3458   5                                        display_cnasc(0x90,6,"输入旧密码：");
3459   5                                        while(1)
3460   5                                        {
3461   6                                          key=input_passwork();
3462   6                                          if(key==10) break;
3463   6                                          key=passwork_comp();
3464   6                                          if(key==1)
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 57  

3465   6                                          {
3466   7                                            display_cnasc(0x92,1,"新");
3467   7                                                display_cnasc(0x89,6,"            ");
3468   7                                            key=input_passwork();
3469   7                                                if(key==10) break;
3470   7                                                display_cnasc(0x90,6,"确认密码：  ");
3471   7                                                input_second_passwork();
3472   7                                                break;                
3473   7                                          }
3474   6                                        }
3475   5                                        break;
3476   5                    case 2: 
3477   5                                display_cnasc(0x82,3,"初始化");
3478   5                                display_cnasc(0x91,6,"是否初始化? ");
3479   5                        display_cnasc(0x89,6,"Y(OK)\\N(./S)");
3480   5                                        while(1)
3481   5                                        {
3482   6                                          key=gotkey();
3483   6                                              if(key==11)
3484   6                                              {
3485   7                                                clear_dis();
3486   7                                                dis_title_e();
3487   7                                                display_cnasc(0x82,3,"初始化");
3488   7                                                display_cnasc(0x90,5,"输入密码：");
3489   7                                                do
3490   7                                                {
3491   8                                                  key=input_passwork();
3492   8                                                  if(key==10) break;
3493   8                                                  key=passwork_comp();
3494   8                                                  if(key==1)
3495   8                                                  {
3496   9                                                        display_cnasc(0x90,5,"密码正确！");
3497   9                                                        display_cnasc(0x89,7,"\x10 初始化中... ");
3498   9                                                        init_ds1302();
3499   9                                                        rds1302_data();
3500   9                                                        delay_pw();
3501   9                                                        display_cnasc(0x9a,6,"\x10 完成！(OK)");
3502   9                                                        while(gotkey()!=11);
3503   9                                                        key=10;
3504   9                                                        break;
3505   9                                                  }
3506   8                                                }while(1);
3507   7                                              }
3508   6                                              if(key==10) break;
3509   6                                        }
3510   5                                        break;
3511   5                      }
3512   4                      key=99;save=d;
3513   4                }
3514   3                if(key==99) break;
3515   3              }while(1);
3516   2        }while(1);
3517   1      }
3518          
3519          
3520          /*=====================================================================================
3521           函数名称：版本信息
3522           功能描述：  
3523           全局变量：
3524           参数说明：见函数
3525           返回说明：无
3526           设 计 人：LIJH
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 58  

3527           版    本：1.0
3528           说    明：
3529           ======================================================================================*/
3530          
3531          void version_func(void)
3532          {
3533   1        uchar save,v=0;
3534   1        display_cnasc(0x82,3,"版  本");
3535   1        dis_title_e();
3536   1        do
3537   1        {
3538   2              display_cnasc(0x90,7,version[v]);
3539   2              display_cnasc(0x88,7,version[v+1]);
3540   2              display_cnasc(0x98,7,version[v+2]);
3541   2              if(v!=0) display_cnasc(0x97,1," \x1e");
3542   2              else if(v==0)
3543   2                display_cnasc(0x97,1,"院"); 
3544   2              else display_cnasc(0x97,1,"  ");
3545   2              if(v!=7) display_cnasc(0x9f,1," \x1f");
3546   2              else display_cnasc(0x9f,1,"  ");
3547   2              save=gotkey();
3548   2              if(save==2&&v<7)
3549   2              {
3550   3                display_cnasc(0x9f,1," \x04");
3551   3            delay(30000);
3552   3                v++;
3553   3              }
3554   2              if(save==5&&v>0)
3555   2              {
3556   3                display_cnasc(0x97,1," \x04");
3557   3            delay(30000);
3558   3                v--;
3559   3              }
3560   2              if(save==1) return;
3561   2              if((save==11||save==3)&&v==7) 
3562   2              {
3563   3                display_cnasc(0x9e,2,") \x09 ");
3564   3            delay(30000);
3565   3                return;         
3566   3              }
3567   2        }while(1);
3568   1      }
3569          
3570          
3571          
3572          /*=====================================================================================
3573           函数名称：系统主函数
3574           功能描述：  
3575           全局变量：
3576           参数说明：见函数
3577           返回说明：无
3578           设 计 人：LIJH
3579           版    本：1.0
3580           说    明：
3581           ======================================================================================*/
3582          main()
3583          {
3584   1        uchar key;                                                     
3585   1        init_lcd();                                             // 初始化lcd
3586   1        lcd_bl=als_tl=als_th=buzzer=pw_oc=close;
3587   1        key=r1302(d02_initsi+1);            // 读出1302初始化标记位
3588   1        if(bl1) lcd_bl=close;
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 59  

3589   1        else lcd_bl=open;
3590   1        display_cnasc(0x92,4,"欢迎使用");   // 显示开机画面“欢迎使用”
3591   1        display_cnasc(0x9d,3,"―LiJH");
3592   1        if(key!=0xb4)  init_ds1302();       // DS1302初始化
3593   1        rds1302_data();                                         // 开机读回设置数据
3594   1        rds1302_date();
3595   1        rds1302_time();                     // 读日期时间   
3596   1        if(!ds18b20) init_ds18b20();            // 初始化18b20
3597   1        if(ds18b20) 
3598   1        {                                          
3599   2              ds18b20_func();                                    // 读出温度
3600   2        } 
3601   1        time_init();                         // 定时器初始化
3602   1        delay_pw();resu[11]=0; 
3603   1        while(1)
3604   1        {  
3605   2              EA=1;
3606   2              TR0=1;
3607   2              dis_sig=1;      
3608   2              clear_dis();
3609   2              if(di0){init_d2=1;dis_mode2();init_d2=0;}
3610   2          else if(di1) dis_mode3();
3611   2          else dis_mode1();   
3612   2              do
3613   2              {
3614   3                key=gotkey();
3615   3                if(key==255)                  // 键盘密码输入
3616   3                {
3617   4                      TR0=0;
3618   4                      dis_sig=0;
3619   4                      clear_dis();
3620   4                      dis_title_e();
3621   4                      display_cnasc(0x82,3,"键盘锁");
3622   4                      display_cnasc(0x90,5,"输入密码：");
3623   4                      while(1)
3624   4                      {
3625   5                        keb=0;
3626   5                        key=input_passwork();
3627   5                        if(key==10) {keb=1;resu[11]=2;break;}
3628   5                        key=passwork_comp();
3629   5                        if(key==1) {keb=1;resu[11]=0;break;}    
3630   5                      }
3631   4                      rds1302_date();
3632   4              rds1302_time();
3633   4                  save_time=now;
3634   4                      break;
3635   4                }
3636   3                if(key==11)
3637   3                {
3638   4                  dis_menu_key(1);
3639   4                      delay(35000);
3640   4                      do
3641   4                      {
3642   5                        dis_sig=0;
3643   5                        TR0=0;
3644   5                        clear_dis();
3645   5                        key=dis_menu();
3646   5                        clear_dis();
3647   5                        if(key==0) adjust_func();
3648   5                        else if(key==1) // 调用相应程序功能S
3649   5                        {
3650   6                          while(1)
C51 COMPILER V8.02   _制系统                                                              08/08/2008 18:31:54 PAGE 60  

3651   6                              {
3652   7                                clear_dis();
3653   7                            key=tool_func();
3654   7                                if(key==4) break;
3655   7                                clear_dis(); 
3656   7                                switch(key)
3657   7                                {
3658   8                                  case 0:     calculator();
3659   8                                              break;
3660   8                                      case 1: temp_func();
3661   8                                              break;
3662   8                                      case 2: alarm_func();
3663   8                                              break;
3664   8                                      case 3: nba_timer();
3665   8                                              break;
3666   8                                }
3667   7                              }
3668   6                        }
3669   5                        else if(key==2)       set_func();
3670   5                        else if(key==3)       passw_func();
3671   5                        else if(key==4) version_func();
3672   5                        else
3673   5                        {
3674   6                          rds1302_date();
3675   6                  rds1302_time();
3676   6                              save_time=now;
3677   6                              resu[11]=0;
3678   6                              dis_sig=1;
3679   6                              break;
3680   6                        }
3681   5                      }while(1);
3682   4                }
3683   3                if(dis_sig) break;
3684   3              }while(1);
3685   2        }
3686   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  15154    ----
   CONSTANT SIZE    =   4068    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5     121
   IDATA SIZE       =     58    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
